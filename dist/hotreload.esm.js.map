{
  "version": 3,
  "sources": ["../js/config.js", "../js/logger.js", "../js/reloaders/replace_html_reloader.js", "../node_modules/idiomorph/dist/idiomorph.esm.js", "../js/helpers.js", "../js/reloaders/stimulus_reloader.js", "../js/reloaders/morph_html_reloader.js", "../js/reloaders/css_reloader.js", "../js/channels/index.js", "../js/index.js"],
  "sourcesContent": ["const config = {\n  loggingEnabled: getConfigurationProperty(\"logging\") ?? false,\n  htmlReloadMethod: getConfigurationProperty(\"html-reload-method\"),\n};\n\ndocument.addEventListener(\"turbo:load\", () => {\n  reloadConfigs();\n});\n\nfunction reloadConfigs() {\n  config.loggingEnabled = getConfigurationProperty(\"logging\") ?? false;\n  config.htmlReloadMethod = getConfigurationProperty(\"html-reload-method\");\n}\n\nfunction getConfigurationProperty(name) {\n  return document.querySelector(`meta[name=\"hotwire-hotreload:${name}\"]`)\n    ?.content;\n}\n\nexport default config;\n", "import config from \"./config\";\n\nexport function log(...messages) {\n  if (config.loggingEnabled) {\n    console.log(`[hotwire hotreload]`, ...messages);\n  }\n}\n", "import { log } from \"../logger.js\";\n\nexport class ReplaceHtmlReloader {\n  static async reload() {\n    return new ReplaceHtmlReloader().reload();\n  }\n\n  async reload() {\n    await this.#reloadHtml();\n  }\n\n  async #reloadHtml() {\n    log(\"Reload html with Turbo...\");\n\n    this.#keepScrollPosition();\n    await this.#visitCurrentPage();\n  }\n\n  #keepScrollPosition() {\n    document.addEventListener(\n      \"turbo:before-render\",\n      () => {\n        Turbo.navigator.currentVisit.scrolled = true;\n      },\n      { once: true },\n    );\n  }\n\n  #visitCurrentPage() {\n    return new Promise((resolve) => {\n      document.addEventListener(\"turbo:load\", () => resolve(document), {\n        once: true,\n      });\n      window.Turbo.visit(window.location, { action: \"replace\" });\n    });\n  }\n}\n", "/**\n * @typedef {object} ConfigHead\n *\n * @property {'merge' | 'append' | 'morph' | 'none'} [style]\n * @property {boolean} [block]\n * @property {boolean} [ignore]\n * @property {function(Element): boolean} [shouldPreserve]\n * @property {function(Element): boolean} [shouldReAppend]\n * @property {function(Element): boolean} [shouldRemove]\n * @property {function(Element, {added: Node[], kept: Element[], removed: Element[]}): void} [afterHeadMorphed]\n */\n\n/**\n * @typedef {object} ConfigCallbacks\n *\n * @property {function(Node): boolean} [beforeNodeAdded]\n * @property {function(Node): void} [afterNodeAdded]\n * @property {function(Element, Node): boolean} [beforeNodeMorphed]\n * @property {function(Element, Node): void} [afterNodeMorphed]\n * @property {function(Element): boolean} [beforeNodeRemoved]\n * @property {function(Element): void} [afterNodeRemoved]\n * @property {function(string, Element, \"update\" | \"remove\"): boolean} [beforeAttributeUpdated]\n * @property {function(Element): boolean} [beforeNodePantried]\n */\n\n/**\n * @typedef {object} Config\n *\n * @property {'outerHTML' | 'innerHTML'} [morphStyle]\n * @property {boolean} [ignoreActive]\n * @property {boolean} [ignoreActiveValue]\n * @property {ConfigCallbacks} [callbacks]\n * @property {ConfigHead} [head]\n */\n\n/**\n * @typedef {function} NoOp\n *\n * @returns {void}\n */\n\n/**\n * @typedef {object} ConfigHeadInternal\n *\n * @property {'merge' | 'append' | 'morph' | 'none'} style\n * @property {boolean} [block]\n * @property {boolean} [ignore]\n * @property {(function(Element): boolean) | NoOp} shouldPreserve\n * @property {(function(Element): boolean) | NoOp} shouldReAppend\n * @property {(function(Element): boolean) | NoOp} shouldRemove\n * @property {(function(Element, {added: Node[], kept: Element[], removed: Element[]}): void) | NoOp} afterHeadMorphed\n */\n\n/**\n * @typedef {object} ConfigCallbacksInternal\n *\n * @property {(function(Node): boolean) | NoOp} beforeNodeAdded\n * @property {(function(Node): void) | NoOp} afterNodeAdded\n * @property {(function(Node, Node): boolean) | NoOp} beforeNodeMorphed\n * @property {(function(Node, Node): void) | NoOp} afterNodeMorphed\n * @property {(function(Node): boolean) | NoOp} beforeNodeRemoved\n * @property {(function(Node): void) | NoOp} afterNodeRemoved\n * @property {(function(string, Element, \"update\" | \"remove\"): boolean) | NoOp} beforeAttributeUpdated\n * @property {(function(Node): boolean) | NoOp} beforeNodePantried\n */\n\n/**\n * @typedef {object} ConfigInternal\n *\n * @property {'outerHTML' | 'innerHTML'} morphStyle\n * @property {boolean} [ignoreActive]\n * @property {boolean} [ignoreActiveValue]\n * @property {ConfigCallbacksInternal} callbacks\n * @property {ConfigHeadInternal} head\n * @property {boolean} [twoPass]\n */\n\n/**\n * @typedef {Function} Morph\n *\n * @param {Element | Document} oldNode\n * @param {Element | Node | HTMLCollection | Node[] | string | null} newContent\n * @param {Config} [config]\n * @returns {undefined | Node[]}\n */\n\n// base IIFE to define idiomorph\n/**\n *\n * @type {{defaults: ConfigInternal, morph: Morph}}\n */\nvar Idiomorph = (function () {\n  \"use strict\";\n\n  /**\n   * @typedef {object} MorphContext\n   *\n   * @property {Node} target\n   * @property {Node} newContent\n   * @property {ConfigInternal} config\n   * @property {ConfigInternal['morphStyle']} morphStyle\n   * @property {ConfigInternal['ignoreActive']} ignoreActive\n   * @property {ConfigInternal['ignoreActiveValue']} ignoreActiveValue\n   * @property {Map<Node, Set<string>>} idMap\n   * @property {Set<string>} persistentIds\n   * @property {Set<string>} deadIds\n   * @property {ConfigInternal['callbacks']} callbacks\n   * @property {ConfigInternal['head']} head\n   * @property {HTMLDivElement} pantry\n   */\n\n  //=============================================================================\n  // AND NOW IT BEGINS...\n  //=============================================================================\n\n  /**\n   *\n   * @type {Set<string>}\n   */\n  let EMPTY_SET = new Set();\n\n  /**\n   * Default configuration values, updatable by users now\n   * @type {ConfigInternal}\n   */\n  let defaults = {\n    morphStyle: \"outerHTML\",\n    callbacks: {\n      beforeNodeAdded: noOp,\n      afterNodeAdded: noOp,\n      beforeNodeMorphed: noOp,\n      afterNodeMorphed: noOp,\n      beforeNodeRemoved: noOp,\n      afterNodeRemoved: noOp,\n      beforeAttributeUpdated: noOp,\n      beforeNodePantried: noOp,\n    },\n    head: {\n      style: \"merge\",\n      shouldPreserve: function (elt) {\n        return elt.getAttribute(\"im-preserve\") === \"true\";\n      },\n      shouldReAppend: function (elt) {\n        return elt.getAttribute(\"im-re-append\") === \"true\";\n      },\n      shouldRemove: noOp,\n      afterHeadMorphed: noOp,\n    },\n  };\n\n  /**\n   * =============================================================================\n   * Core Morphing Algorithm - morph, morphNormalizedContent, morphOldNodeTo, morphChildren\n   * =============================================================================\n   *\n   * @param {Element | Document} oldNode\n   * @param {Element | Node | HTMLCollection | Node[] | string | null} newContent\n   * @param {Config} [config]\n   * @returns {undefined | Node[]}\n   */\n  function morph(oldNode, newContent, config = {}) {\n    if (oldNode instanceof Document) {\n      oldNode = oldNode.documentElement;\n    }\n\n    if (typeof newContent === \"string\") {\n      newContent = parseContent(newContent);\n    }\n\n    let normalizedContent = normalizeContent(newContent);\n\n    let ctx = createMorphContext(oldNode, normalizedContent, config);\n\n    return morphNormalizedContent(oldNode, normalizedContent, ctx);\n  }\n\n  /**\n   *\n   * @param {Element} oldNode\n   * @param {Element} normalizedNewContent\n   * @param {MorphContext} ctx\n   * @returns {undefined | Node[]}\n   */\n  function morphNormalizedContent(oldNode, normalizedNewContent, ctx) {\n    if (ctx.head.block) {\n      let oldHead = oldNode.querySelector(\"head\");\n      let newHead = normalizedNewContent.querySelector(\"head\");\n      if (oldHead && newHead) {\n        let promises = handleHeadElement(newHead, oldHead, ctx);\n        // when head promises resolve, call morph again, ignoring the head tag\n        Promise.all(promises).then(function () {\n          morphNormalizedContent(\n            oldNode,\n            normalizedNewContent,\n            Object.assign(ctx, {\n              head: {\n                block: false,\n                ignore: true,\n              },\n            }),\n          );\n        });\n        return;\n      }\n    }\n\n    if (ctx.morphStyle === \"innerHTML\") {\n      // innerHTML, so we are only updating the children\n      morphChildren(normalizedNewContent, oldNode, ctx);\n      if (ctx.config.twoPass) {\n        restoreFromPantry(oldNode, ctx);\n      }\n      return Array.from(oldNode.children);\n    } else if (ctx.morphStyle === \"outerHTML\" || ctx.morphStyle == null) {\n      // otherwise find the best element match in the new content, morph that, and merge its siblings\n      // into either side of the best match\n      let bestMatch = findBestNodeMatch(normalizedNewContent, oldNode, ctx);\n\n      // stash the siblings that will need to be inserted on either side of the best match\n      let previousSibling = bestMatch?.previousSibling ?? null;\n      let nextSibling = bestMatch?.nextSibling ?? null;\n\n      // morph it\n      let morphedNode = morphOldNodeTo(oldNode, bestMatch, ctx);\n\n      if (bestMatch) {\n        // if there was a best match, merge the siblings in too and return the\n        // whole bunch\n        if (morphedNode) {\n          const elements = insertSiblings(\n            previousSibling,\n            morphedNode,\n            nextSibling,\n          );\n          if (ctx.config.twoPass) {\n            restoreFromPantry(morphedNode.parentNode, ctx);\n          }\n          return elements;\n        }\n      } else {\n        // otherwise nothing was added to the DOM\n        return [];\n      }\n    } else {\n      throw \"Do not understand how to morph style \" + ctx.morphStyle;\n    }\n  }\n\n  /**\n   * @param {Node} possibleActiveElement\n   * @param {MorphContext} ctx\n   * @returns {boolean}\n   */\n  // TODO: ignoreActive and ignoreActiveValue are marked as optional since they are not\n  //   initialised in the default config object. As a result the && in the function body may\n  //   return undefined instead of boolean. Either expand the type of the return value to\n  //   include undefined or wrap the ctx.ignoreActiveValue into a Boolean()\n  function ignoreValueOfActiveElement(possibleActiveElement, ctx) {\n    return (\n      !!ctx.ignoreActiveValue &&\n      possibleActiveElement === document.activeElement &&\n      possibleActiveElement !== document.body\n    );\n  }\n\n  /**\n   * @param {Node} oldNode root node to merge content into\n   * @param {Node | null} newContent new content to merge\n   * @param {MorphContext} ctx the merge context\n   * @returns {Node | null} the element that ended up in the DOM\n   */\n  function morphOldNodeTo(oldNode, newContent, ctx) {\n    if (ctx.ignoreActive && oldNode === document.activeElement) {\n      // don't morph focused element\n    } else if (newContent == null) {\n      if (ctx.callbacks.beforeNodeRemoved(oldNode) === false) return oldNode;\n\n      oldNode.parentNode?.removeChild(oldNode);\n      ctx.callbacks.afterNodeRemoved(oldNode);\n      return null;\n    } else if (!isSoftMatch(oldNode, newContent)) {\n      if (ctx.callbacks.beforeNodeRemoved(oldNode) === false) return oldNode;\n      if (ctx.callbacks.beforeNodeAdded(newContent) === false) return oldNode;\n\n      oldNode.parentNode?.replaceChild(newContent, oldNode);\n      ctx.callbacks.afterNodeAdded(newContent);\n      ctx.callbacks.afterNodeRemoved(oldNode);\n      return newContent;\n    } else {\n      if (ctx.callbacks.beforeNodeMorphed(oldNode, newContent) === false)\n        return oldNode;\n\n      if (oldNode instanceof HTMLHeadElement && ctx.head.ignore) {\n        // ignore the head element\n      } else if (\n        oldNode instanceof HTMLHeadElement &&\n        ctx.head.style !== \"morph\"\n      ) {\n        // ok to cast: if newContent wasn't also a <head>, it would've got caught in the `!isSoftMatch` branch above\n        handleHeadElement(\n          /** @type {HTMLHeadElement} */ (newContent),\n          oldNode,\n          ctx,\n        );\n      } else {\n        syncNodeFrom(newContent, oldNode, ctx);\n        if (!ignoreValueOfActiveElement(oldNode, ctx)) {\n          morphChildren(newContent, oldNode, ctx);\n        }\n      }\n      ctx.callbacks.afterNodeMorphed(oldNode, newContent);\n      return oldNode;\n    }\n    return null;\n  }\n\n  /**\n   * This is the core algorithm for matching up children.  The idea is to use id sets to try to match up\n   * nodes as faithfully as possible.  We greedily match, which allows us to keep the algorithm fast, but\n   * by using id sets, we are able to better match up with content deeper in the DOM.\n   *\n   * Basic algorithm is, for each node in the new content:\n   *\n   * - if we have reached the end of the old parent, append the new content\n   * - if the new content has an id set match with the current insertion point, morph\n   * - search for an id set match\n   * - if id set match found, morph\n   * - otherwise search for a \"soft\" match\n   * - if a soft match is found, morph\n   * - otherwise, prepend the new node before the current insertion point\n   *\n   * The two search algorithms terminate if competing node matches appear to outweigh what can be achieved\n   * with the current node.  See findIdSetMatch() and findSoftMatch() for details.\n   *\n   * @param {Node} newParent the parent element of the new content\n   * @param {Node} oldParent the old content that we are merging the new content into\n   * @param {MorphContext} ctx the merge context\n   * @returns {void}\n   */\n  function morphChildren(newParent, oldParent, ctx) {\n    if (\n      newParent instanceof HTMLTemplateElement &&\n      oldParent instanceof HTMLTemplateElement\n    ) {\n      newParent = newParent.content;\n      oldParent = oldParent.content;\n    }\n\n    /**\n     *\n     * @type {Node | null}\n     */\n    let nextNewChild = newParent.firstChild;\n    /**\n     *\n     * @type {Node | null}\n     */\n    let insertionPoint = oldParent.firstChild;\n    let newChild;\n\n    // run through all the new content\n    while (nextNewChild) {\n      newChild = nextNewChild;\n      nextNewChild = newChild.nextSibling;\n\n      // if we are at the end of the exiting parent's children, just append\n      if (insertionPoint == null) {\n        // skip add callbacks when we're going to be restoring this from the pantry in the second pass\n        if (\n          ctx.config.twoPass &&\n          ctx.persistentIds.has(/** @type {Element} */ (newChild).id)\n        ) {\n          oldParent.appendChild(newChild);\n        } else {\n          if (ctx.callbacks.beforeNodeAdded(newChild) === false) continue;\n          oldParent.appendChild(newChild);\n          ctx.callbacks.afterNodeAdded(newChild);\n        }\n        removeIdsFromConsideration(ctx, newChild);\n        continue;\n      }\n\n      // if the current node has an id set match then morph\n      if (isIdSetMatch(newChild, insertionPoint, ctx)) {\n        morphOldNodeTo(insertionPoint, newChild, ctx);\n        insertionPoint = insertionPoint.nextSibling;\n        removeIdsFromConsideration(ctx, newChild);\n        continue;\n      }\n\n      // otherwise search forward in the existing old children for an id set match\n      let idSetMatch = findIdSetMatch(\n        newParent,\n        oldParent,\n        newChild,\n        insertionPoint,\n        ctx,\n      );\n\n      // if we found a potential match, remove the nodes until that point and morph\n      if (idSetMatch) {\n        insertionPoint = removeNodesBetween(insertionPoint, idSetMatch, ctx);\n        morphOldNodeTo(idSetMatch, newChild, ctx);\n        removeIdsFromConsideration(ctx, newChild);\n        continue;\n      }\n\n      // no id set match found, so scan forward for a soft match for the current node\n      let softMatch = findSoftMatch(\n        newParent,\n        oldParent,\n        newChild,\n        insertionPoint,\n        ctx,\n      );\n\n      // if we found a soft match for the current node, morph\n      if (softMatch) {\n        insertionPoint = removeNodesBetween(insertionPoint, softMatch, ctx);\n        morphOldNodeTo(softMatch, newChild, ctx);\n        removeIdsFromConsideration(ctx, newChild);\n        continue;\n      }\n\n      // abandon all hope of morphing, just insert the new child before the insertion point\n      // and move on\n\n      // skip add callbacks when we're going to be restoring this from the pantry in the second pass\n      if (\n        ctx.config.twoPass &&\n        ctx.persistentIds.has(/** @type {Element} */ (newChild).id)\n      ) {\n        oldParent.insertBefore(newChild, insertionPoint);\n      } else {\n        if (ctx.callbacks.beforeNodeAdded(newChild) === false) continue;\n        oldParent.insertBefore(newChild, insertionPoint);\n        ctx.callbacks.afterNodeAdded(newChild);\n      }\n      removeIdsFromConsideration(ctx, newChild);\n    }\n\n    // remove any remaining old nodes that didn't match up with new content\n    while (insertionPoint !== null) {\n      let tempNode = insertionPoint;\n      insertionPoint = insertionPoint.nextSibling;\n      removeNode(tempNode, ctx);\n    }\n  }\n\n  //=============================================================================\n  // Attribute Syncing Code\n  //=============================================================================\n\n  /**\n   * @param {string} attr the attribute to be mutated\n   * @param {Element} to the element that is going to be updated\n   * @param {\"update\" | \"remove\"} updateType\n   * @param {MorphContext} ctx the merge context\n   * @returns {boolean} true if the attribute should be ignored, false otherwise\n   */\n  function ignoreAttribute(attr, to, updateType, ctx) {\n    if (\n      attr === \"value\" &&\n      ctx.ignoreActiveValue &&\n      to === document.activeElement\n    ) {\n      return true;\n    }\n    return ctx.callbacks.beforeAttributeUpdated(attr, to, updateType) === false;\n  }\n\n  /**\n   * syncs a given node with another node, copying over all attributes and\n   * inner element state from the 'from' node to the 'to' node\n   *\n   * @param {Node} from the element to copy attributes & state from\n   * @param {Node} to the element to copy attributes & state to\n   * @param {MorphContext} ctx the merge context\n   */\n  function syncNodeFrom(from, to, ctx) {\n    let type = from.nodeType;\n\n    // if is an element type, sync the attributes from the\n    // new node into the new node\n    if (type === 1 /* element type */) {\n      const fromEl = /** @type {Element} */ (from);\n      const toEl = /** @type {Element} */ (to);\n      const fromAttributes = fromEl.attributes;\n      const toAttributes = toEl.attributes;\n      for (const fromAttribute of fromAttributes) {\n        if (ignoreAttribute(fromAttribute.name, toEl, \"update\", ctx)) {\n          continue;\n        }\n        if (toEl.getAttribute(fromAttribute.name) !== fromAttribute.value) {\n          toEl.setAttribute(fromAttribute.name, fromAttribute.value);\n        }\n      }\n      // iterate backwards to avoid skipping over items when a delete occurs\n      for (let i = toAttributes.length - 1; 0 <= i; i--) {\n        const toAttribute = toAttributes[i];\n\n        // toAttributes is a live NamedNodeMap, so iteration+mutation is unsafe\n        // e.g. custom element attribute callbacks can remove other attributes\n        if (!toAttribute) continue;\n\n        if (!fromEl.hasAttribute(toAttribute.name)) {\n          if (ignoreAttribute(toAttribute.name, toEl, \"remove\", ctx)) {\n            continue;\n          }\n          toEl.removeAttribute(toAttribute.name);\n        }\n      }\n    }\n\n    // sync text nodes\n    if (type === 8 /* comment */ || type === 3 /* text */) {\n      if (to.nodeValue !== from.nodeValue) {\n        to.nodeValue = from.nodeValue;\n      }\n    }\n\n    if (!ignoreValueOfActiveElement(to, ctx)) {\n      // sync input values\n      syncInputValue(from, to, ctx);\n    }\n  }\n\n  /**\n   * @param {Element} from element to sync the value from\n   * @param {Element} to element to sync the value to\n   * @param {string} attributeName the attribute name\n   * @param {MorphContext} ctx the merge context\n   */\n  function syncBooleanAttribute(from, to, attributeName, ctx) {\n    // TODO: prefer set/getAttribute here\n    if (!(from instanceof Element && to instanceof Element)) return;\n    // @ts-ignore this function is only used on boolean attrs that are reflected as dom properties\n    const fromLiveValue = from[attributeName],\n      toLiveValue = to[attributeName];\n    if (fromLiveValue !== toLiveValue) {\n      let ignoreUpdate = ignoreAttribute(attributeName, to, \"update\", ctx);\n      if (!ignoreUpdate) {\n        // update attribute's associated DOM property\n        // @ts-ignore this function is only used on boolean attrs that are reflected as dom properties\n        to[attributeName] = from[attributeName];\n      }\n      if (fromLiveValue) {\n        if (!ignoreUpdate) {\n          // TODO: do we really want this? tests say so but it feels wrong\n          to.setAttribute(attributeName, fromLiveValue);\n        }\n      } else {\n        if (!ignoreAttribute(attributeName, to, \"remove\", ctx)) {\n          to.removeAttribute(attributeName);\n        }\n      }\n    }\n  }\n\n  /**\n   * NB: many bothans died to bring us information:\n   *\n   *  https://github.com/patrick-steele-idem/morphdom/blob/master/src/specialElHandlers.js\n   *  https://github.com/choojs/nanomorph/blob/master/lib/morph.jsL113\n   *\n   * @param {Node} from the element to sync the input value from\n   * @param {Node} to the element to sync the input value to\n   * @param {MorphContext} ctx the merge context\n   */\n  function syncInputValue(from, to, ctx) {\n    if (\n      from instanceof HTMLInputElement &&\n      to instanceof HTMLInputElement &&\n      from.type !== \"file\"\n    ) {\n      let fromValue = from.value;\n      let toValue = to.value;\n\n      // sync boolean attributes\n      syncBooleanAttribute(from, to, \"checked\", ctx);\n      syncBooleanAttribute(from, to, \"disabled\", ctx);\n\n      if (!from.hasAttribute(\"value\")) {\n        if (!ignoreAttribute(\"value\", to, \"remove\", ctx)) {\n          to.value = \"\";\n          to.removeAttribute(\"value\");\n        }\n      } else if (fromValue !== toValue) {\n        if (!ignoreAttribute(\"value\", to, \"update\", ctx)) {\n          to.setAttribute(\"value\", fromValue);\n          to.value = fromValue;\n        }\n      }\n      // TODO: QUESTION(1cg): this used to only check `from` unlike the other branches -- why?\n      // did I break something?\n    } else if (\n      from instanceof HTMLOptionElement &&\n      to instanceof HTMLOptionElement\n    ) {\n      syncBooleanAttribute(from, to, \"selected\", ctx);\n    } else if (\n      from instanceof HTMLTextAreaElement &&\n      to instanceof HTMLTextAreaElement\n    ) {\n      let fromValue = from.value;\n      let toValue = to.value;\n      if (ignoreAttribute(\"value\", to, \"update\", ctx)) {\n        return;\n      }\n      if (fromValue !== toValue) {\n        to.value = fromValue;\n      }\n      if (to.firstChild && to.firstChild.nodeValue !== fromValue) {\n        to.firstChild.nodeValue = fromValue;\n      }\n    }\n  }\n\n  /**\n   * =============================================================================\n   *  The HEAD tag can be handled specially, either w/ a 'merge' or 'append' style\n   * =============================================================================\n   * @param {Element} newHeadTag\n   * @param {Element} currentHead\n   * @param {MorphContext} ctx\n   * @returns {Promise<void>[]}\n   */\n  function handleHeadElement(newHeadTag, currentHead, ctx) {\n    /**\n     * @type {Node[]}\n     */\n    let added = [];\n    /**\n     * @type {Element[]}\n     */\n    let removed = [];\n    /**\n     * @type {Element[]}\n     */\n    let preserved = [];\n    /**\n     * @type {Element[]}\n     */\n    let nodesToAppend = [];\n\n    let headMergeStyle = ctx.head.style;\n\n    // put all new head elements into a Map, by their outerHTML\n    let srcToNewHeadNodes = new Map();\n    for (const newHeadChild of newHeadTag.children) {\n      srcToNewHeadNodes.set(newHeadChild.outerHTML, newHeadChild);\n    }\n\n    // for each elt in the current head\n    for (const currentHeadElt of currentHead.children) {\n      // If the current head element is in the map\n      let inNewContent = srcToNewHeadNodes.has(currentHeadElt.outerHTML);\n      let isReAppended = ctx.head.shouldReAppend(currentHeadElt);\n      let isPreserved = ctx.head.shouldPreserve(currentHeadElt);\n      if (inNewContent || isPreserved) {\n        if (isReAppended) {\n          // remove the current version and let the new version replace it and re-execute\n          removed.push(currentHeadElt);\n        } else {\n          // this element already exists and should not be re-appended, so remove it from\n          // the new content map, preserving it in the DOM\n          srcToNewHeadNodes.delete(currentHeadElt.outerHTML);\n          preserved.push(currentHeadElt);\n        }\n      } else {\n        if (headMergeStyle === \"append\") {\n          // we are appending and this existing element is not new content\n          // so if and only if it is marked for re-append do we do anything\n          if (isReAppended) {\n            removed.push(currentHeadElt);\n            nodesToAppend.push(currentHeadElt);\n          }\n        } else {\n          // if this is a merge, we remove this content since it is not in the new head\n          if (ctx.head.shouldRemove(currentHeadElt) !== false) {\n            removed.push(currentHeadElt);\n          }\n        }\n      }\n    }\n\n    // Push the remaining new head elements in the Map into the\n    // nodes to append to the head tag\n    nodesToAppend.push(...srcToNewHeadNodes.values());\n    log(\"to append: \", nodesToAppend);\n\n    let promises = [];\n    for (const newNode of nodesToAppend) {\n      log(\"adding: \", newNode);\n      // TODO: This could theoretically be null, based on type\n      let newElt = /** @type {ChildNode} */ (\n        document.createRange().createContextualFragment(newNode.outerHTML)\n          .firstChild\n      );\n      log(newElt);\n      if (ctx.callbacks.beforeNodeAdded(newElt) !== false) {\n        if (\n          (\"href\" in newElt && newElt.href) ||\n          (\"src\" in newElt && newElt.src)\n        ) {\n          /** @type {(result?: any) => void} */ let resolve;\n          let promise = new Promise(function (_resolve) {\n            resolve = _resolve;\n          });\n          newElt.addEventListener(\"load\", function () {\n            resolve();\n          });\n          promises.push(promise);\n        }\n        currentHead.appendChild(newElt);\n        ctx.callbacks.afterNodeAdded(newElt);\n        added.push(newElt);\n      }\n    }\n\n    // remove all removed elements, after we have appended the new elements to avoid\n    // additional network requests for things like style sheets\n    for (const removedElement of removed) {\n      if (ctx.callbacks.beforeNodeRemoved(removedElement) !== false) {\n        currentHead.removeChild(removedElement);\n        ctx.callbacks.afterNodeRemoved(removedElement);\n      }\n    }\n\n    ctx.head.afterHeadMorphed(currentHead, {\n      added: added,\n      kept: preserved,\n      removed: removed,\n    });\n    return promises;\n  }\n\n  //=============================================================================\n  // Misc\n  //=============================================================================\n\n  /**\n   * @param {any[]} _args\n   */\n  function log(..._args) {\n    //console.log(args);\n  }\n\n  function noOp() {}\n\n  /**\n   * Deep merges the config object and the Idiomoroph.defaults object to\n   * produce a final configuration object\n   * @param {Config} config\n   * @returns {ConfigInternal}\n   */\n  function mergeDefaults(config) {\n    /**\n     * @type {ConfigInternal}\n     */\n    let finalConfig = Object.assign({}, defaults);\n\n    // copy top level stuff into final config\n    Object.assign(finalConfig, config);\n\n    // copy callbacks into final config (do this to deep merge the callbacks)\n    finalConfig.callbacks = Object.assign(\n      {},\n      defaults.callbacks,\n      config.callbacks,\n    );\n\n    // copy head config into final config  (do this to deep merge the head)\n    finalConfig.head = Object.assign({}, defaults.head, config.head);\n\n    return finalConfig;\n  }\n\n  /**\n   *\n   * @param {Element} oldNode\n   * @param {Element} newContent\n   * @param {Config} config\n   * @returns {MorphContext}\n   */\n  function createMorphContext(oldNode, newContent, config) {\n    const mergedConfig = mergeDefaults(config);\n    return {\n      target: oldNode,\n      newContent: newContent,\n      config: mergedConfig,\n      morphStyle: mergedConfig.morphStyle,\n      ignoreActive: mergedConfig.ignoreActive,\n      ignoreActiveValue: mergedConfig.ignoreActiveValue,\n      idMap: createIdMap(oldNode, newContent),\n      deadIds: new Set(),\n      persistentIds: mergedConfig.twoPass\n        ? createPersistentIds(oldNode, newContent)\n        : new Set(),\n      pantry: mergedConfig.twoPass\n        ? createPantry()\n        : document.createElement(\"div\"),\n      callbacks: mergedConfig.callbacks,\n      head: mergedConfig.head,\n    };\n  }\n\n  function createPantry() {\n    const pantry = document.createElement(\"div\");\n    pantry.hidden = true;\n    document.body.insertAdjacentElement(\"afterend\", pantry);\n    return pantry;\n  }\n\n  /**\n   *\n   * @param {Node | null} node1\n   * @param {Node | null} node2\n   * @param {MorphContext} ctx\n   * @returns {boolean}\n   */\n  // TODO: The function handles this as if it's Element or null, but the function is called in\n  //   places where the arguments may be just a Node, not an Element\n  function isIdSetMatch(node1, node2, ctx) {\n    if (node1 == null || node2 == null) {\n      return false;\n    }\n    if (\n      node1 instanceof Element &&\n      node2 instanceof Element &&\n      node1.tagName === node2.tagName\n    ) {\n      if (node1.id !== \"\" && node1.id === node2.id) {\n        return true;\n      } else {\n        return getIdIntersectionCount(ctx, node1, node2) > 0;\n      }\n    }\n    return false;\n  }\n\n  /**\n   *\n   * @param {Node | null} oldNode\n   * @param {Node | null} newNode\n   * @returns {boolean}\n   */\n  function isSoftMatch(oldNode, newNode) {\n    if (oldNode == null || newNode == null) {\n      return false;\n    }\n    // ok to cast: if one is not element, `id` or `tagName` will be undefined and we'll compare that\n    // If oldNode has an `id` with possible state and it doesn't match newNode.id then avoid morphing\n    if (\n      /** @type {Element} */ (oldNode).id &&\n      /** @type {Element} */ (oldNode).id !==\n        /** @type {Element} */ (newNode).id\n    ) {\n      return false;\n    }\n    return (\n      oldNode.nodeType === newNode.nodeType &&\n      /** @type {Element} */ (oldNode).tagName ===\n        /** @type {Element} */ (newNode).tagName\n    );\n  }\n\n  /**\n   *\n   * @param {Node} startInclusive\n   * @param {Node} endExclusive\n   * @param {MorphContext} ctx\n   * @returns {Node | null}\n   */\n  function removeNodesBetween(startInclusive, endExclusive, ctx) {\n    /** @type {Node | null} */ let cursor = startInclusive;\n    while (cursor !== endExclusive) {\n      let tempNode = /** @type {Node} */ (cursor);\n      // TODO: Prefer assigning to a new variable here or expand the type of startInclusive\n      //  to be Node | null\n      cursor = tempNode.nextSibling;\n      removeNode(tempNode, ctx);\n    }\n    removeIdsFromConsideration(ctx, endExclusive);\n    return endExclusive.nextSibling;\n  }\n\n  /**\n   * =============================================================================\n   *  Scans forward from the insertionPoint in the old parent looking for a potential id match\n   *  for the newChild.  We stop if we find a potential id match for the new child OR\n   *  if the number of potential id matches we are discarding is greater than the\n   *  potential id matches for the new child\n   * =============================================================================\n   * @param {Node} newContent\n   * @param {Node} oldParent\n   * @param {Node} newChild\n   * @param {Node} insertionPoint\n   * @param {MorphContext} ctx\n   * @returns {null | Node}\n   */\n  function findIdSetMatch(\n    newContent,\n    oldParent,\n    newChild,\n    insertionPoint,\n    ctx,\n  ) {\n    // max id matches we are willing to discard in our search\n    let newChildPotentialIdCount = getIdIntersectionCount(\n      ctx,\n      newChild,\n      oldParent,\n    );\n\n    /**\n     * @type {Node | null}\n     */\n    let potentialMatch = null;\n\n    // only search forward if there is a possibility of an id match\n    if (newChildPotentialIdCount > 0) {\n      // TODO: This is ghosting the potentialMatch variable outside of this block.\n      //   Probably an error\n      potentialMatch = insertionPoint;\n      // if there is a possibility of an id match, scan forward\n      // keep track of the potential id match count we are discarding (the\n      // newChildPotentialIdCount must be greater than this to make it likely\n      // worth it)\n      let otherMatchCount = 0;\n      while (potentialMatch != null) {\n        // If we have an id match, return the current potential match\n        if (isIdSetMatch(newChild, potentialMatch, ctx)) {\n          return potentialMatch;\n        }\n\n        // computer the other potential matches of this new content\n        otherMatchCount += getIdIntersectionCount(\n          ctx,\n          potentialMatch,\n          newContent,\n        );\n        if (otherMatchCount > newChildPotentialIdCount) {\n          // if we have more potential id matches in _other_ content, we\n          // do not have a good candidate for an id match, so return null\n          return null;\n        }\n\n        // advanced to the next old content child\n        potentialMatch = potentialMatch.nextSibling;\n      }\n    }\n    return potentialMatch;\n  }\n\n  /**\n   * =============================================================================\n   *  Scans forward from the insertionPoint in the old parent looking for a potential soft match\n   *  for the newChild.  We stop if we find a potential soft match for the new child OR\n   *  if we find a potential id match in the old parents children OR if we find two\n   *  potential soft matches for the next two pieces of new content\n   * =============================================================================\n   * @param {Node} newContent\n   * @param {Node} oldParent\n   * @param {Node} newChild\n   * @param {Node} insertionPoint\n   * @param {MorphContext} ctx\n   * @returns {null | Node}\n   */\n  function findSoftMatch(newContent, oldParent, newChild, insertionPoint, ctx) {\n    /**\n     * @type {Node | null}\n     */\n    let potentialSoftMatch = insertionPoint;\n    /**\n     * @type {Node | null}\n     */\n    let nextSibling = newChild.nextSibling;\n    let siblingSoftMatchCount = 0;\n\n    while (potentialSoftMatch != null) {\n      if (getIdIntersectionCount(ctx, potentialSoftMatch, newContent) > 0) {\n        // the current potential soft match has a potential id set match with the remaining new\n        // content so bail out of looking\n        return null;\n      }\n\n      // if we have a soft match with the current node, return it\n      if (isSoftMatch(potentialSoftMatch, newChild)) {\n        return potentialSoftMatch;\n      }\n\n      if (isSoftMatch(potentialSoftMatch, nextSibling)) {\n        // the next new node has a soft match with this node, so\n        // increment the count of future soft matches\n        siblingSoftMatchCount++;\n        // ok to cast: if it was null it couldn't be a soft match\n        nextSibling = /** @type {Node} */ (nextSibling).nextSibling;\n\n        // If there are two future soft matches, bail to allow the siblings to soft match\n        // so that we don't consume future soft matches for the sake of the current node\n        if (siblingSoftMatchCount >= 2) {\n          return null;\n        }\n      }\n\n      // advanced to the next old content child\n      potentialSoftMatch = potentialSoftMatch.nextSibling;\n    }\n\n    return potentialSoftMatch;\n  }\n\n  /** @type {WeakSet<Node>} */\n  const generatedByIdiomorph = new WeakSet();\n\n  /**\n   *\n   * @param {string} newContent\n   * @returns {Node | null | DocumentFragment}\n   */\n  function parseContent(newContent) {\n    let parser = new DOMParser();\n\n    // remove svgs to avoid false-positive matches on head, etc.\n    let contentWithSvgsRemoved = newContent.replace(\n      /<svg(\\s[^>]*>|>)([\\s\\S]*?)<\\/svg>/gim,\n      \"\",\n    );\n\n    // if the newContent contains a html, head or body tag, we can simply parse it w/o wrapping\n    if (\n      contentWithSvgsRemoved.match(/<\\/html>/) ||\n      contentWithSvgsRemoved.match(/<\\/head>/) ||\n      contentWithSvgsRemoved.match(/<\\/body>/)\n    ) {\n      let content = parser.parseFromString(newContent, \"text/html\");\n      // if it is a full HTML document, return the document itself as the parent container\n      if (contentWithSvgsRemoved.match(/<\\/html>/)) {\n        generatedByIdiomorph.add(content);\n        return content;\n      } else {\n        // otherwise return the html element as the parent container\n        let htmlElement = content.firstChild;\n        if (htmlElement) {\n          generatedByIdiomorph.add(htmlElement);\n          return htmlElement;\n        } else {\n          return null;\n        }\n      }\n    } else {\n      // if it is partial HTML, wrap it in a template tag to provide a parent element and also to help\n      // deal with touchy tags like tr, tbody, etc.\n      let responseDoc = parser.parseFromString(\n        \"<body><template>\" + newContent + \"</template></body>\",\n        \"text/html\",\n      );\n      let content = /** @type {HTMLTemplateElement} */ (\n        responseDoc.body.querySelector(\"template\")\n      ).content;\n      generatedByIdiomorph.add(content);\n      return content;\n    }\n  }\n\n  /**\n   *\n   * @param {null | Node | HTMLCollection | Node[] | Document & {generatedByIdiomorph:boolean}} newContent\n   * @returns {Element}\n   */\n  function normalizeContent(newContent) {\n    if (newContent == null) {\n      // noinspection UnnecessaryLocalVariableJS\n      const dummyParent = document.createElement(\"div\");\n      return dummyParent;\n    } else if (generatedByIdiomorph.has(/** @type {Element} */ (newContent))) {\n      // the template tag created by idiomorph parsing can serve as a dummy parent\n      return /** @type {Element} */ (newContent);\n    } else if (newContent instanceof Node) {\n      // a single node is added as a child to a dummy parent\n      const dummyParent = document.createElement(\"div\");\n      dummyParent.append(newContent);\n      return dummyParent;\n    } else {\n      // all nodes in the array or HTMLElement collection are consolidated under\n      // a single dummy parent element\n      const dummyParent = document.createElement(\"div\");\n      for (const elt of [...newContent]) {\n        dummyParent.append(elt);\n      }\n      return dummyParent;\n    }\n  }\n\n  /**\n   *\n   * @param {Node | null} previousSibling\n   * @param {Node} morphedNode\n   * @param {Node | null} nextSibling\n   * @returns {Node[]}\n   */\n  function insertSiblings(previousSibling, morphedNode, nextSibling) {\n    /**\n     * @type {Node[]}\n     */\n    let stack = [];\n    /**\n     * @type {Node[]}\n     */\n    let added = [];\n    while (previousSibling != null) {\n      stack.push(previousSibling);\n      previousSibling = previousSibling.previousSibling;\n    }\n    // Base the loop on the node variable, so that you do not need runtime checks for\n    // undefined value inside the loop\n    let node = stack.pop();\n    while (node !== undefined) {\n      added.push(node); // push added preceding siblings on in order and insert\n      morphedNode.parentElement?.insertBefore(node, morphedNode);\n      node = stack.pop();\n    }\n    added.push(morphedNode);\n    while (nextSibling != null) {\n      stack.push(nextSibling);\n      added.push(nextSibling); // here we are going in order, so push on as we scan, rather than add\n      nextSibling = nextSibling.nextSibling;\n    }\n    while (stack.length > 0) {\n      const node = /** @type {Node} */ (stack.pop());\n      morphedNode.parentElement?.insertBefore(node, morphedNode.nextSibling);\n    }\n    return added;\n  }\n\n  /**\n   *\n   * @param {Element} newContent\n   * @param {Element} oldNode\n   * @param {MorphContext} ctx\n   * @returns {Node | null}\n   */\n  function findBestNodeMatch(newContent, oldNode, ctx) {\n    /**\n     * @type {Node | null}\n     */\n    let currentElement;\n    currentElement = newContent.firstChild;\n    /**\n     * @type {Node | null}\n     */\n    let bestElement = currentElement;\n    let score = 0;\n    while (currentElement) {\n      let newScore = scoreElement(currentElement, oldNode, ctx);\n      if (newScore > score) {\n        bestElement = currentElement;\n        score = newScore;\n      }\n      currentElement = currentElement.nextSibling;\n    }\n    return bestElement;\n  }\n\n  /**\n   *\n   * @param {Node | null} node1\n   * @param {Element} node2\n   * @param {MorphContext} ctx\n   * @returns {number}\n   */\n  // TODO: The function handles node1 and node2 as if they are Elements but the function is\n  //   called in places where node1 and node2 may be just Nodes, not Elements\n  function scoreElement(node1, node2, ctx) {\n    if (isSoftMatch(node2, node1)) {\n      // ok to cast: isSoftMatch performs a null check\n      return (\n        0.5 + getIdIntersectionCount(ctx, /** @type {Node} */ (node1), node2)\n      );\n    }\n    return 0;\n  }\n\n  /**\n   *\n   * @param {Node} tempNode\n   * @param {MorphContext} ctx\n   */\n  // TODO: The function handles tempNode as if it's Element but the function is called in\n  //   places where tempNode may be just a Node, not an Element\n  function removeNode(tempNode, ctx) {\n    removeIdsFromConsideration(ctx, tempNode);\n    // skip remove callbacks when we're going to be restoring this from the pantry in the second pass\n    if (\n      ctx.config.twoPass &&\n      hasPersistentIdNodes(ctx, tempNode) &&\n      tempNode instanceof Element\n    ) {\n      moveToPantry(tempNode, ctx);\n    } else {\n      if (ctx.callbacks.beforeNodeRemoved(tempNode) === false) return;\n      tempNode.parentNode?.removeChild(tempNode);\n      ctx.callbacks.afterNodeRemoved(tempNode);\n    }\n  }\n\n  /**\n   *\n   * @param {Node} node\n   * @param {MorphContext} ctx\n   */\n  function moveToPantry(node, ctx) {\n    if (ctx.callbacks.beforeNodePantried(node) === false) return;\n\n    Array.from(node.childNodes).forEach((child) => {\n      moveToPantry(child, ctx);\n    });\n\n    // After processing children, process the current node\n    if (ctx.persistentIds.has(/** @type {Element} */ (node).id)) {\n      // @ts-ignore - use proposed moveBefore feature\n      if (ctx.pantry.moveBefore) {\n        // @ts-ignore - use proposed moveBefore feature\n        ctx.pantry.moveBefore(node, null);\n      } else {\n        ctx.pantry.insertBefore(node, null);\n      }\n    } else {\n      if (ctx.callbacks.beforeNodeRemoved(node) === false) return;\n      node.parentNode?.removeChild(node);\n      ctx.callbacks.afterNodeRemoved(node);\n    }\n  }\n\n  /**\n   *\n   * @param {Node | null} root\n   * @param {MorphContext} ctx\n   */\n  function restoreFromPantry(root, ctx) {\n    if (root instanceof Element) {\n      Array.from(ctx.pantry.children)\n        .reverse()\n        .forEach((element) => {\n          const matchElement = root.querySelector(`#${element.id}`);\n          if (matchElement) {\n            // @ts-ignore - use proposed moveBefore feature\n            if (matchElement.parentElement?.moveBefore) {\n              // @ts-ignore - use proposed moveBefore feature\n              matchElement.parentElement.moveBefore(element, matchElement);\n              while (matchElement.hasChildNodes()) {\n                // @ts-ignore - use proposed moveBefore feature\n                element.moveBefore(matchElement.firstChild, null);\n              }\n            } else {\n              matchElement.before(element);\n              while (matchElement.firstChild) {\n                element.insertBefore(matchElement.firstChild, null);\n              }\n            }\n            if (\n              ctx.callbacks.beforeNodeMorphed(element, matchElement) !== false\n            ) {\n              syncNodeFrom(matchElement, element, ctx);\n              ctx.callbacks.afterNodeMorphed(element, matchElement);\n            }\n            matchElement.remove();\n          }\n        });\n      ctx.pantry.remove();\n    }\n  }\n\n  //=============================================================================\n  // ID Set Functions\n  //=============================================================================\n\n  /**\n   *\n   * @param {MorphContext} ctx\n   * @param {string} id\n   * @returns {boolean}\n   */\n  function isIdInConsideration(ctx, id) {\n    return !ctx.deadIds.has(id);\n  }\n\n  /**\n   *\n   * @param {MorphContext} ctx\n   * @param {string} id\n   * @param {Node} targetNode\n   * @returns {boolean}\n   */\n  function idIsWithinNode(ctx, id, targetNode) {\n    let idSet = ctx.idMap.get(targetNode) || EMPTY_SET;\n    return idSet.has(id);\n  }\n\n  /**\n   *\n   * @param {MorphContext} ctx\n   * @param {Node} node\n   * @returns {void}\n   */\n  function removeIdsFromConsideration(ctx, node) {\n    let idSet = ctx.idMap.get(node) || EMPTY_SET;\n    for (const id of idSet) {\n      ctx.deadIds.add(id);\n    }\n  }\n\n  /**\n   *\n   * @param {MorphContext} ctx\n   * @param {Node} node\n   * @returns {boolean}\n   */\n  function hasPersistentIdNodes(ctx, node) {\n    for (const id of ctx.idMap.get(node) || EMPTY_SET) {\n      if (ctx.persistentIds.has(id)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   *\n   * @param {MorphContext} ctx\n   * @param {Node} node1\n   * @param {Node} node2\n   * @returns {number}\n   */\n  function getIdIntersectionCount(ctx, node1, node2) {\n    let sourceSet = ctx.idMap.get(node1) || EMPTY_SET;\n    let matchCount = 0;\n    for (const id of sourceSet) {\n      // a potential match is an id in the source and potentialIdsSet, but\n      // that has not already been merged into the DOM\n      if (isIdInConsideration(ctx, id) && idIsWithinNode(ctx, id, node2)) {\n        ++matchCount;\n      }\n    }\n    return matchCount;\n  }\n\n  /**\n   * @param {Element} content\n   * @returns {Element[]}\n   */\n  function nodesWithIds(content) {\n    let nodes = Array.from(content.querySelectorAll(\"[id]\"));\n    if (content.id) {\n      nodes.push(content);\n    }\n    return nodes;\n  }\n\n  /**\n   * A bottom up algorithm that finds all elements with ids in the node\n   * argument and populates id sets for those nodes and all their parents, generating\n   * a set of ids contained within all nodes for the entire hierarchy in the DOM\n   *\n   * @param {Element} node\n   * @param {Map<Node, Set<string>>} idMap\n   */\n  function populateIdMapForNode(node, idMap) {\n    let nodeParent = node.parentElement;\n    for (const elt of nodesWithIds(node)) {\n      /**\n       * @type {Element|null}\n       */\n      let current = elt;\n      // walk up the parent hierarchy of that element, adding the id\n      // of element to the parent's id set\n      while (current !== nodeParent && current != null) {\n        let idSet = idMap.get(current);\n        // if the id set doesn't exist, create it and insert it in the  map\n        if (idSet == null) {\n          idSet = new Set();\n          idMap.set(current, idSet);\n        }\n        idSet.add(elt.id);\n        current = current.parentElement;\n      }\n    }\n  }\n\n  /**\n   * This function computes a map of nodes to all ids contained within that node (inclusive of the\n   * node).  This map can be used to ask if two nodes have intersecting sets of ids, which allows\n   * for a looser definition of \"matching\" than tradition id matching, and allows child nodes\n   * to contribute to a parent nodes matching.\n   *\n   * @param {Element} oldContent  the old content that will be morphed\n   * @param {Element} newContent  the new content to morph to\n   * @returns {Map<Node, Set<string>>} a map of nodes to id sets for the\n   */\n  function createIdMap(oldContent, newContent) {\n    /**\n     *\n     * @type {Map<Node, Set<string>>}\n     */\n    let idMap = new Map();\n    populateIdMapForNode(oldContent, idMap);\n    populateIdMapForNode(newContent, idMap);\n    return idMap;\n  }\n\n  /**\n   * @param {Element} oldContent  the old content that will be morphed\n   * @param {Element} newContent  the new content to morph to\n   * @returns {Set<string>} the id set of all persistent nodes that exist in both old and new content\n   */\n  function createPersistentIds(oldContent, newContent) {\n    const toIdTagName = (node) => node.tagName + \"#\" + node.id;\n    const oldIdSet = new Set(nodesWithIds(oldContent).map(toIdTagName));\n\n    let matchIdSet = new Set();\n    for (const newNode of nodesWithIds(newContent)) {\n      if (oldIdSet.has(toIdTagName(newNode))) {\n        matchIdSet.add(newNode.id);\n      }\n    }\n    return matchIdSet;\n  }\n\n  //=============================================================================\n  // This is what ends up becoming the Idiomorph global object\n  //=============================================================================\n  return {\n    morph,\n    defaults,\n  };\n})();\n\nexport {Idiomorph};\n", "export function assetNameFromPath(path) {\n  return path.split(\"/\").pop().split(\".\")[0];\n}\n\nexport function pathWithoutAssetDigest(path) {\n  return path.replace(/\\?.*$/, \"\");\n}\n\nexport function urlWithParams(urlString, params) {\n  const url = new URL(urlString, window.location.origin);\n\n  Object.entries(params).forEach(([key, value]) => {\n    url.searchParams.set(key, value);\n  });\n\n  return url.toString();\n}\n\nexport function cacheBustedUrl(urlString) {\n  return urlWithParams(urlString, { reload: Date.now() });\n}\n\nexport async function reloadHtmlDocument() {\n  let currentUrl = cacheBustedUrl(\n    urlWithParams(window.location.href, { hotwire_spark: \"true\" }),\n  );\n\n  const response = await fetch(currentUrl, {\n    headers: { Accept: \"text/html\" },\n  });\n\n  if (!response.ok) {\n    throw new Error(`${response.status} when fetching ${currentUrl}`);\n  }\n\n  const fetchedHTML = await response.text();\n  const parser = new DOMParser();\n  return parser.parseFromString(fetchedHTML, \"text/html\");\n}\n\nexport function getConfigurationProperty(name) {\n  return document.querySelector(`meta[name=\"hotwire-hotreload:${name}\"]`)\n    ?.content;\n}\n", "import { log } from \"../logger.js\";\nimport { cacheBustedUrl, reloadHtmlDocument } from \"../helpers.js\";\n\nexport class StimulusReloader {\n  static async reload(changedFilePath) {\n    const document = await reloadHtmlDocument();\n    return new StimulusReloader(document, changedFilePath).reload();\n  }\n\n  static async reloadAll() {\n    Stimulus.controllers.forEach((controller) => {\n      Stimulus.unload(controller.identifier);\n      Stimulus.register(controller.identifier, controller.constructor);\n    });\n\n    return Promise.resolve();\n  }\n\n  constructor(document, changedFilePath) {\n    this.document = document;\n    this.changedFilePath = changedFilePath;\n    this.application = window.Stimulus;\n  }\n\n  async reload() {\n    log(\"Reload Stimulus controllers...\");\n\n    this.application.stop();\n\n    await this.#reloadChangedStimulusControllers();\n    this.#unloadDeletedStimulusControllers();\n\n    this.application.start();\n  }\n\n  async #reloadChangedStimulusControllers() {\n    await Promise.all(\n      this.#stimulusControllerPathsToReload.map(async (moduleName) =>\n        this.#reloadStimulusController(moduleName),\n      ),\n    );\n  }\n\n  get #stimulusControllerPathsToReload() {\n    this.controllerPathsToReload =\n      this.controllerPathsToReload ||\n      this.#stimulusControllerPaths.filter((path) =>\n        this.#shouldReloadController(path),\n      );\n    return this.controllerPathsToReload;\n  }\n\n  get #stimulusControllerPaths() {\n    return Object.keys(this.#stimulusPathsByModule).filter((path) =>\n      path.endsWith(\"_controller\"),\n    );\n  }\n\n  #shouldReloadController(path) {\n    return (\n      this.#extractControllerName(path) === this.#changedControllerIdentifier\n    );\n  }\n\n  get #changedControllerIdentifier() {\n    this.changedControllerIdentifier =\n      this.changedControllerIdentifier ||\n      this.#extractControllerName(this.changedFilePath);\n    return this.changedControllerIdentifier;\n  }\n\n  get #stimulusPathsByModule() {\n    this.pathsByModule = this.pathsByModule || this.#parseImportmapJson();\n    return this.pathsByModule;\n  }\n\n  #parseImportmapJson() {\n    const importmapScript = this.document.querySelector(\n      \"script[type=importmap]\",\n    );\n    return JSON.parse(importmapScript.text).imports;\n  }\n\n  async #reloadStimulusController(moduleName) {\n    log(`\\t${moduleName}`);\n\n    const controllerName = this.#extractControllerName(moduleName);\n    const path = cacheBustedUrl(this.#pathForModuleName(moduleName));\n\n    const module = await import(path);\n\n    this.#registerController(controllerName, module);\n  }\n\n  #unloadDeletedStimulusControllers() {\n    this.#controllersToUnload.forEach((controller) =>\n      this.#deregisterController(controller.identifier),\n    );\n  }\n\n  get #controllersToUnload() {\n    if (this.#didChangeTriggerAReload) {\n      return [];\n    } else {\n      return this.application.controllers.filter(\n        (controller) =>\n          this.#changedControllerIdentifier === controller.identifier,\n      );\n    }\n  }\n\n  get #didChangeTriggerAReload() {\n    return this.#stimulusControllerPathsToReload.length > 0;\n  }\n\n  #pathForModuleName(moduleName) {\n    return this.#stimulusPathsByModule[moduleName];\n  }\n\n  #extractControllerName(path) {\n    return path\n      .replace(/^\\/+/, \"\")\n      .replace(/^controllers\\//, \"\")\n      .replace(\"_controller\", \"\")\n      .replace(/\\//g, \"--\")\n      .replace(/_/g, \"-\")\n      .replace(/\\.js$/, \"\");\n  }\n\n  #registerController(name, module) {\n    this.application.unload(name);\n    this.application.register(name, module.default);\n  }\n\n  #deregisterController(name) {\n    log(`\\tRemoving controller ${name}`);\n    this.application.unload(name);\n  }\n}\n", "import { Idiomorph } from \"idiomorph/dist/idiomorph.esm.js\";\nimport { reloadHtmlDocument } from \"../helpers.js\";\nimport { log } from \"../logger.js\";\nimport { StimulusReloader } from \"./stimulus_reloader.js\";\n\nexport class MorphHtmlReloader {\n  static async reload() {\n    return new MorphHtmlReloader().reload();\n  }\n\n  async reload() {\n    await this.#reloadHtml();\n    await this.#reloadStimulus();\n  }\n\n  async #reloadHtml() {\n    log(\"Reload html with morph...\");\n\n    const reloadedDocument = await reloadHtmlDocument();\n    this.#updateBody(reloadedDocument.body);\n    return reloadedDocument;\n  }\n\n  #updateBody(newBody) {\n    Idiomorph.morph(document.body, newBody);\n  }\n\n  async #reloadStimulus() {\n    await StimulusReloader.reloadAll();\n  }\n}\n", "import { log } from \"../logger.js\";\nimport {\n  cacheBustedUrl,\n  reloadHtmlDocument,\n  pathWithoutAssetDigest,\n} from \"../helpers.js\";\n\nexport class CssReloader {\n  static async reload(...params) {\n    return new CssReloader(...params).reload();\n  }\n\n  constructor(filePattern = /./) {\n    this.filePattern = filePattern;\n  }\n\n  async reload() {\n    log(\"Reload css...\");\n    await Promise.all(await this.#reloadAllLinks());\n  }\n\n  async #reloadAllLinks() {\n    const cssLinks = await this.#loadNewCssLinks();\n    return cssLinks.map((link) => this.#reloadLinkIfNeeded(link));\n  }\n\n  async #loadNewCssLinks() {\n    const reloadedDocument = await reloadHtmlDocument();\n    return Array.from(\n      reloadedDocument.head.querySelectorAll(\"link[rel='stylesheet']\"),\n    );\n  }\n\n  #reloadLinkIfNeeded(link) {\n    if (this.#shouldReloadLink(link)) {\n      return this.#reloadLink(link);\n    } else {\n      return Promise.resolve();\n    }\n  }\n\n  #shouldReloadLink(link) {\n    return this.filePattern.test(link.getAttribute(\"href\"));\n  }\n\n  async #reloadLink(link) {\n    return new Promise((resolve) => {\n      const href = link.getAttribute(\"href\");\n      const newLink =\n        this.#findExistingLinkFor(link) || this.#appendNewLink(link);\n\n      newLink.setAttribute(\"href\", cacheBustedUrl(link.getAttribute(\"href\")));\n      newLink.onload = () => {\n        log(`\\t${href}`);\n        resolve();\n      };\n    });\n  }\n\n  #findExistingLinkFor(link) {\n    return this.#cssLinks.find(\n      (newLink) =>\n        pathWithoutAssetDigest(link.href) ===\n        pathWithoutAssetDigest(newLink.href),\n    );\n  }\n\n  get #cssLinks() {\n    return Array.from(document.querySelectorAll(\"link[rel='stylesheet']\"));\n  }\n\n  #appendNewLink(link) {\n    document.head.append(link);\n    return link;\n  }\n}\n", "import { ReplaceHtmlReloader } from \"../reloaders/replace_html_reloader.js\";\nimport { MorphHtmlReloader } from \"../reloaders/morph_html_reloader.js\";\nimport { StimulusReloader } from \"../reloaders/stimulus_reloader.js\";\nimport { CssReloader } from \"../reloaders/css_reloader.js\";\nimport { assetNameFromPath } from \"../helpers.js\";\n\nclass ServerSentEventsChannel {\n  static async start() {\n    const sse = new EventSource(\"/hotwired-laravel-hotreload/sse\");\n\n    sse.addEventListener(\n      \"tick\",\n      () => {\n        document.body.setAttribute(\"data-hotwire-hotreload-ready\", \"true\");\n      },\n      { once: true },\n    );\n\n    sse.addEventListener(\"reload_html\", (event) => {\n      const data = JSON.parse(event.data);\n\n      const reloader =\n        HotwireHotreload.config.htmlReloadMethod === \"morph\"\n          ? MorphHtmlReloader\n          : ReplaceHtmlReloader;\n\n      return reloader.reload(data.path);\n    });\n\n    sse.addEventListener(\"reload_stimulus\", (event) => {\n      if (window.Stimulus !== undefined) {\n        const data = JSON.parse(event.data);\n        return StimulusReloader.reload(data.path);\n      }\n    });\n\n    sse.addEventListener(\"reload_css\", (event) => {\n      const data = JSON.parse(event.data);\n      return CssReloader.reload(new RegExp(assetNameFromPath(data.path)));\n    });\n  }\n}\n\nServerSentEventsChannel.start();\n", "import config from \"./config.js\";\nimport \"./channels/index.js\";\n\nconst HotwireHotreload = {\n  config,\n};\n\nwindow.HotwireHotreload = HotwireHotreload;\n"],
  "mappings": "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",
  "names": ["config", "log", "node", "document", "HotwireHotreload"]
}
