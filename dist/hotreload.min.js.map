{
  "version": 3,
  "sources": ["../js/logger.js", "../js/reloaders/replace_html_reloader.js", "../js/helpers.js", "../node_modules/idiomorph/dist/idiomorph.esm.js", "../js/reloaders/stimulus_reloader.js", "../js/reloaders/morph_html_reloader.js", "../js/reloaders/css_reloader.js", "../js/channels/index.js", "../js/index.js"],
  "sourcesContent": ["import HotwireHotreload from \"./index.js\";\n\nexport function log(...messages) {\n  if (HotwireHotreload.config.loggingEnabled) {\n    console.log(`[hotwire hotreload]`, ...messages);\n  }\n}\n", "import { log } from \"../logger.js\";\n\nexport class ReplaceHtmlReloader {\n  static async reload() {\n    return new ReplaceHtmlReloader().reload();\n  }\n\n  async reload() {\n    await this.#reloadHtml();\n  }\n\n  async #reloadHtml() {\n    log(\"Reload html with Turbo...\");\n\n    this.#keepScrollPosition();\n    await this.#visitCurrentPage();\n  }\n\n  #keepScrollPosition() {\n    document.addEventListener(\n      \"turbo:before-render\",\n      () => {\n        Turbo.navigator.currentVisit.scrolled = true;\n      },\n      { once: true },\n    );\n  }\n\n  #visitCurrentPage() {\n    return new Promise((resolve) => {\n      document.addEventListener(\"turbo:load\", () => resolve(document), {\n        once: true,\n      });\n      window.Turbo.cache.clear();\n      window.Turbo.visit(window.location);\n    });\n  }\n}\n", "export function assetNameFromPath(path) {\n  return path.split(\"/\").pop().split(\".\")[0];\n}\n\nexport function pathWithoutAssetDigest(path) {\n  return path.replace(/-[a-z0-9]+\\.(\\w+)(\\?.*)?$/, \".$1\");\n}\n\nexport function urlWithParams(urlString, params) {\n  const url = new URL(urlString, window.location.origin);\n\n  Object.entries(params).forEach(([key, value]) => {\n    url.searchParams.set(key, value);\n  });\n\n  return url.toString();\n}\n\nexport function cacheBustedUrl(urlString) {\n  return urlWithParams(urlString, { reload: Date.now() });\n}\n\nexport async function reloadHtmlDocument() {\n  let currentUrl = cacheBustedUrl(\n    urlWithParams(window.location.href, { hotwire_spark: \"true\" }),\n  );\n\n  const response = await fetch(currentUrl, {\n    headers: { Accept: \"text/html\" },\n  });\n\n  if (!response.ok) {\n    throw new Error(`${response.status} when fetching ${currentUrl}`);\n  }\n\n  const fetchedHTML = await response.text();\n  const parser = new DOMParser();\n  return parser.parseFromString(fetchedHTML, \"text/html\");\n}\n\nexport function getConfigurationProperty(name) {\n  return document.querySelector(`meta[name=\"hotwire-hotreload:${name}\"]`)\n    ?.content;\n}\n", "/**\n * @typedef {object} ConfigHead\n *\n * @property {'merge' | 'append' | 'morph' | 'none'} [style]\n * @property {boolean} [block]\n * @property {boolean} [ignore]\n * @property {function(Element): boolean} [shouldPreserve]\n * @property {function(Element): boolean} [shouldReAppend]\n * @property {function(Element): boolean} [shouldRemove]\n * @property {function(Element, {added: Node[], kept: Element[], removed: Element[]}): void} [afterHeadMorphed]\n */\n\n/**\n * @typedef {object} ConfigCallbacks\n *\n * @property {function(Node): boolean} [beforeNodeAdded]\n * @property {function(Node): void} [afterNodeAdded]\n * @property {function(Element, Node): boolean} [beforeNodeMorphed]\n * @property {function(Element, Node): void} [afterNodeMorphed]\n * @property {function(Element): boolean} [beforeNodeRemoved]\n * @property {function(Element): void} [afterNodeRemoved]\n * @property {function(string, Element, \"update\" | \"remove\"): boolean} [beforeAttributeUpdated]\n * @property {function(Element): boolean} [beforeNodePantried]\n */\n\n/**\n * @typedef {object} Config\n *\n * @property {'outerHTML' | 'innerHTML'} [morphStyle]\n * @property {boolean} [ignoreActive]\n * @property {boolean} [ignoreActiveValue]\n * @property {ConfigCallbacks} [callbacks]\n * @property {ConfigHead} [head]\n */\n\n/**\n * @typedef {function} NoOp\n *\n * @returns {void}\n */\n\n/**\n * @typedef {object} ConfigHeadInternal\n *\n * @property {'merge' | 'append' | 'morph' | 'none'} style\n * @property {boolean} [block]\n * @property {boolean} [ignore]\n * @property {(function(Element): boolean) | NoOp} shouldPreserve\n * @property {(function(Element): boolean) | NoOp} shouldReAppend\n * @property {(function(Element): boolean) | NoOp} shouldRemove\n * @property {(function(Element, {added: Node[], kept: Element[], removed: Element[]}): void) | NoOp} afterHeadMorphed\n */\n\n/**\n * @typedef {object} ConfigCallbacksInternal\n *\n * @property {(function(Node): boolean) | NoOp} beforeNodeAdded\n * @property {(function(Node): void) | NoOp} afterNodeAdded\n * @property {(function(Node, Node): boolean) | NoOp} beforeNodeMorphed\n * @property {(function(Node, Node): void) | NoOp} afterNodeMorphed\n * @property {(function(Node): boolean) | NoOp} beforeNodeRemoved\n * @property {(function(Node): void) | NoOp} afterNodeRemoved\n * @property {(function(string, Element, \"update\" | \"remove\"): boolean) | NoOp} beforeAttributeUpdated\n * @property {(function(Node): boolean) | NoOp} beforeNodePantried\n */\n\n/**\n * @typedef {object} ConfigInternal\n *\n * @property {'outerHTML' | 'innerHTML'} morphStyle\n * @property {boolean} [ignoreActive]\n * @property {boolean} [ignoreActiveValue]\n * @property {ConfigCallbacksInternal} callbacks\n * @property {ConfigHeadInternal} head\n * @property {boolean} [twoPass]\n */\n\n/**\n * @typedef {Function} Morph\n *\n * @param {Element | Document} oldNode\n * @param {Element | Node | HTMLCollection | Node[] | string | null} newContent\n * @param {Config} [config]\n * @returns {undefined | Node[]}\n */\n\n// base IIFE to define idiomorph\n/**\n *\n * @type {{defaults: ConfigInternal, morph: Morph}}\n */\nvar Idiomorph = (function () {\n  \"use strict\";\n\n  /**\n   * @typedef {object} MorphContext\n   *\n   * @property {Node} target\n   * @property {Node} newContent\n   * @property {ConfigInternal} config\n   * @property {ConfigInternal['morphStyle']} morphStyle\n   * @property {ConfigInternal['ignoreActive']} ignoreActive\n   * @property {ConfigInternal['ignoreActiveValue']} ignoreActiveValue\n   * @property {Map<Node, Set<string>>} idMap\n   * @property {Set<string>} persistentIds\n   * @property {Set<string>} deadIds\n   * @property {ConfigInternal['callbacks']} callbacks\n   * @property {ConfigInternal['head']} head\n   * @property {HTMLDivElement} pantry\n   */\n\n  //=============================================================================\n  // AND NOW IT BEGINS...\n  //=============================================================================\n\n  /**\n   *\n   * @type {Set<string>}\n   */\n  let EMPTY_SET = new Set();\n\n  /**\n   * Default configuration values, updatable by users now\n   * @type {ConfigInternal}\n   */\n  let defaults = {\n    morphStyle: \"outerHTML\",\n    callbacks: {\n      beforeNodeAdded: noOp,\n      afterNodeAdded: noOp,\n      beforeNodeMorphed: noOp,\n      afterNodeMorphed: noOp,\n      beforeNodeRemoved: noOp,\n      afterNodeRemoved: noOp,\n      beforeAttributeUpdated: noOp,\n      beforeNodePantried: noOp,\n    },\n    head: {\n      style: \"merge\",\n      shouldPreserve: function (elt) {\n        return elt.getAttribute(\"im-preserve\") === \"true\";\n      },\n      shouldReAppend: function (elt) {\n        return elt.getAttribute(\"im-re-append\") === \"true\";\n      },\n      shouldRemove: noOp,\n      afterHeadMorphed: noOp,\n    },\n  };\n\n  /**\n   * =============================================================================\n   * Core Morphing Algorithm - morph, morphNormalizedContent, morphOldNodeTo, morphChildren\n   * =============================================================================\n   *\n   * @param {Element | Document} oldNode\n   * @param {Element | Node | HTMLCollection | Node[] | string | null} newContent\n   * @param {Config} [config]\n   * @returns {undefined | Node[]}\n   */\n  function morph(oldNode, newContent, config = {}) {\n    if (oldNode instanceof Document) {\n      oldNode = oldNode.documentElement;\n    }\n\n    if (typeof newContent === \"string\") {\n      newContent = parseContent(newContent);\n    }\n\n    let normalizedContent = normalizeContent(newContent);\n\n    let ctx = createMorphContext(oldNode, normalizedContent, config);\n\n    return morphNormalizedContent(oldNode, normalizedContent, ctx);\n  }\n\n  /**\n   *\n   * @param {Element} oldNode\n   * @param {Element} normalizedNewContent\n   * @param {MorphContext} ctx\n   * @returns {undefined | Node[]}\n   */\n  function morphNormalizedContent(oldNode, normalizedNewContent, ctx) {\n    if (ctx.head.block) {\n      let oldHead = oldNode.querySelector(\"head\");\n      let newHead = normalizedNewContent.querySelector(\"head\");\n      if (oldHead && newHead) {\n        let promises = handleHeadElement(newHead, oldHead, ctx);\n        // when head promises resolve, call morph again, ignoring the head tag\n        Promise.all(promises).then(function () {\n          morphNormalizedContent(\n            oldNode,\n            normalizedNewContent,\n            Object.assign(ctx, {\n              head: {\n                block: false,\n                ignore: true,\n              },\n            }),\n          );\n        });\n        return;\n      }\n    }\n\n    if (ctx.morphStyle === \"innerHTML\") {\n      // innerHTML, so we are only updating the children\n      morphChildren(normalizedNewContent, oldNode, ctx);\n      if (ctx.config.twoPass) {\n        restoreFromPantry(oldNode, ctx);\n      }\n      return Array.from(oldNode.children);\n    } else if (ctx.morphStyle === \"outerHTML\" || ctx.morphStyle == null) {\n      // otherwise find the best element match in the new content, morph that, and merge its siblings\n      // into either side of the best match\n      let bestMatch = findBestNodeMatch(normalizedNewContent, oldNode, ctx);\n\n      // stash the siblings that will need to be inserted on either side of the best match\n      let previousSibling = bestMatch?.previousSibling ?? null;\n      let nextSibling = bestMatch?.nextSibling ?? null;\n\n      // morph it\n      let morphedNode = morphOldNodeTo(oldNode, bestMatch, ctx);\n\n      if (bestMatch) {\n        // if there was a best match, merge the siblings in too and return the\n        // whole bunch\n        if (morphedNode) {\n          const elements = insertSiblings(\n            previousSibling,\n            morphedNode,\n            nextSibling,\n          );\n          if (ctx.config.twoPass) {\n            restoreFromPantry(morphedNode.parentNode, ctx);\n          }\n          return elements;\n        }\n      } else {\n        // otherwise nothing was added to the DOM\n        return [];\n      }\n    } else {\n      throw \"Do not understand how to morph style \" + ctx.morphStyle;\n    }\n  }\n\n  /**\n   * @param {Node} possibleActiveElement\n   * @param {MorphContext} ctx\n   * @returns {boolean}\n   */\n  // TODO: ignoreActive and ignoreActiveValue are marked as optional since they are not\n  //   initialised in the default config object. As a result the && in the function body may\n  //   return undefined instead of boolean. Either expand the type of the return value to\n  //   include undefined or wrap the ctx.ignoreActiveValue into a Boolean()\n  function ignoreValueOfActiveElement(possibleActiveElement, ctx) {\n    return (\n      !!ctx.ignoreActiveValue &&\n      possibleActiveElement === document.activeElement &&\n      possibleActiveElement !== document.body\n    );\n  }\n\n  /**\n   * @param {Node} oldNode root node to merge content into\n   * @param {Node | null} newContent new content to merge\n   * @param {MorphContext} ctx the merge context\n   * @returns {Node | null} the element that ended up in the DOM\n   */\n  function morphOldNodeTo(oldNode, newContent, ctx) {\n    if (ctx.ignoreActive && oldNode === document.activeElement) {\n      // don't morph focused element\n    } else if (newContent == null) {\n      if (ctx.callbacks.beforeNodeRemoved(oldNode) === false) return oldNode;\n\n      oldNode.parentNode?.removeChild(oldNode);\n      ctx.callbacks.afterNodeRemoved(oldNode);\n      return null;\n    } else if (!isSoftMatch(oldNode, newContent)) {\n      if (ctx.callbacks.beforeNodeRemoved(oldNode) === false) return oldNode;\n      if (ctx.callbacks.beforeNodeAdded(newContent) === false) return oldNode;\n\n      oldNode.parentNode?.replaceChild(newContent, oldNode);\n      ctx.callbacks.afterNodeAdded(newContent);\n      ctx.callbacks.afterNodeRemoved(oldNode);\n      return newContent;\n    } else {\n      if (ctx.callbacks.beforeNodeMorphed(oldNode, newContent) === false)\n        return oldNode;\n\n      if (oldNode instanceof HTMLHeadElement && ctx.head.ignore) {\n        // ignore the head element\n      } else if (\n        oldNode instanceof HTMLHeadElement &&\n        ctx.head.style !== \"morph\"\n      ) {\n        // ok to cast: if newContent wasn't also a <head>, it would've got caught in the `!isSoftMatch` branch above\n        handleHeadElement(\n          /** @type {HTMLHeadElement} */ (newContent),\n          oldNode,\n          ctx,\n        );\n      } else {\n        syncNodeFrom(newContent, oldNode, ctx);\n        if (!ignoreValueOfActiveElement(oldNode, ctx)) {\n          morphChildren(newContent, oldNode, ctx);\n        }\n      }\n      ctx.callbacks.afterNodeMorphed(oldNode, newContent);\n      return oldNode;\n    }\n    return null;\n  }\n\n  /**\n   * This is the core algorithm for matching up children.  The idea is to use id sets to try to match up\n   * nodes as faithfully as possible.  We greedily match, which allows us to keep the algorithm fast, but\n   * by using id sets, we are able to better match up with content deeper in the DOM.\n   *\n   * Basic algorithm is, for each node in the new content:\n   *\n   * - if we have reached the end of the old parent, append the new content\n   * - if the new content has an id set match with the current insertion point, morph\n   * - search for an id set match\n   * - if id set match found, morph\n   * - otherwise search for a \"soft\" match\n   * - if a soft match is found, morph\n   * - otherwise, prepend the new node before the current insertion point\n   *\n   * The two search algorithms terminate if competing node matches appear to outweigh what can be achieved\n   * with the current node.  See findIdSetMatch() and findSoftMatch() for details.\n   *\n   * @param {Node} newParent the parent element of the new content\n   * @param {Node} oldParent the old content that we are merging the new content into\n   * @param {MorphContext} ctx the merge context\n   * @returns {void}\n   */\n  function morphChildren(newParent, oldParent, ctx) {\n    if (\n      newParent instanceof HTMLTemplateElement &&\n      oldParent instanceof HTMLTemplateElement\n    ) {\n      newParent = newParent.content;\n      oldParent = oldParent.content;\n    }\n\n    /**\n     *\n     * @type {Node | null}\n     */\n    let nextNewChild = newParent.firstChild;\n    /**\n     *\n     * @type {Node | null}\n     */\n    let insertionPoint = oldParent.firstChild;\n    let newChild;\n\n    // run through all the new content\n    while (nextNewChild) {\n      newChild = nextNewChild;\n      nextNewChild = newChild.nextSibling;\n\n      // if we are at the end of the exiting parent's children, just append\n      if (insertionPoint == null) {\n        // skip add callbacks when we're going to be restoring this from the pantry in the second pass\n        if (\n          ctx.config.twoPass &&\n          ctx.persistentIds.has(/** @type {Element} */ (newChild).id)\n        ) {\n          oldParent.appendChild(newChild);\n        } else {\n          if (ctx.callbacks.beforeNodeAdded(newChild) === false) continue;\n          oldParent.appendChild(newChild);\n          ctx.callbacks.afterNodeAdded(newChild);\n        }\n        removeIdsFromConsideration(ctx, newChild);\n        continue;\n      }\n\n      // if the current node has an id set match then morph\n      if (isIdSetMatch(newChild, insertionPoint, ctx)) {\n        morphOldNodeTo(insertionPoint, newChild, ctx);\n        insertionPoint = insertionPoint.nextSibling;\n        removeIdsFromConsideration(ctx, newChild);\n        continue;\n      }\n\n      // otherwise search forward in the existing old children for an id set match\n      let idSetMatch = findIdSetMatch(\n        newParent,\n        oldParent,\n        newChild,\n        insertionPoint,\n        ctx,\n      );\n\n      // if we found a potential match, remove the nodes until that point and morph\n      if (idSetMatch) {\n        insertionPoint = removeNodesBetween(insertionPoint, idSetMatch, ctx);\n        morphOldNodeTo(idSetMatch, newChild, ctx);\n        removeIdsFromConsideration(ctx, newChild);\n        continue;\n      }\n\n      // no id set match found, so scan forward for a soft match for the current node\n      let softMatch = findSoftMatch(\n        newParent,\n        oldParent,\n        newChild,\n        insertionPoint,\n        ctx,\n      );\n\n      // if we found a soft match for the current node, morph\n      if (softMatch) {\n        insertionPoint = removeNodesBetween(insertionPoint, softMatch, ctx);\n        morphOldNodeTo(softMatch, newChild, ctx);\n        removeIdsFromConsideration(ctx, newChild);\n        continue;\n      }\n\n      // abandon all hope of morphing, just insert the new child before the insertion point\n      // and move on\n\n      // skip add callbacks when we're going to be restoring this from the pantry in the second pass\n      if (\n        ctx.config.twoPass &&\n        ctx.persistentIds.has(/** @type {Element} */ (newChild).id)\n      ) {\n        oldParent.insertBefore(newChild, insertionPoint);\n      } else {\n        if (ctx.callbacks.beforeNodeAdded(newChild) === false) continue;\n        oldParent.insertBefore(newChild, insertionPoint);\n        ctx.callbacks.afterNodeAdded(newChild);\n      }\n      removeIdsFromConsideration(ctx, newChild);\n    }\n\n    // remove any remaining old nodes that didn't match up with new content\n    while (insertionPoint !== null) {\n      let tempNode = insertionPoint;\n      insertionPoint = insertionPoint.nextSibling;\n      removeNode(tempNode, ctx);\n    }\n  }\n\n  //=============================================================================\n  // Attribute Syncing Code\n  //=============================================================================\n\n  /**\n   * @param {string} attr the attribute to be mutated\n   * @param {Element} to the element that is going to be updated\n   * @param {\"update\" | \"remove\"} updateType\n   * @param {MorphContext} ctx the merge context\n   * @returns {boolean} true if the attribute should be ignored, false otherwise\n   */\n  function ignoreAttribute(attr, to, updateType, ctx) {\n    if (\n      attr === \"value\" &&\n      ctx.ignoreActiveValue &&\n      to === document.activeElement\n    ) {\n      return true;\n    }\n    return ctx.callbacks.beforeAttributeUpdated(attr, to, updateType) === false;\n  }\n\n  /**\n   * syncs a given node with another node, copying over all attributes and\n   * inner element state from the 'from' node to the 'to' node\n   *\n   * @param {Node} from the element to copy attributes & state from\n   * @param {Node} to the element to copy attributes & state to\n   * @param {MorphContext} ctx the merge context\n   */\n  function syncNodeFrom(from, to, ctx) {\n    let type = from.nodeType;\n\n    // if is an element type, sync the attributes from the\n    // new node into the new node\n    if (type === 1 /* element type */) {\n      const fromEl = /** @type {Element} */ (from);\n      const toEl = /** @type {Element} */ (to);\n      const fromAttributes = fromEl.attributes;\n      const toAttributes = toEl.attributes;\n      for (const fromAttribute of fromAttributes) {\n        if (ignoreAttribute(fromAttribute.name, toEl, \"update\", ctx)) {\n          continue;\n        }\n        if (toEl.getAttribute(fromAttribute.name) !== fromAttribute.value) {\n          toEl.setAttribute(fromAttribute.name, fromAttribute.value);\n        }\n      }\n      // iterate backwards to avoid skipping over items when a delete occurs\n      for (let i = toAttributes.length - 1; 0 <= i; i--) {\n        const toAttribute = toAttributes[i];\n\n        // toAttributes is a live NamedNodeMap, so iteration+mutation is unsafe\n        // e.g. custom element attribute callbacks can remove other attributes\n        if (!toAttribute) continue;\n\n        if (!fromEl.hasAttribute(toAttribute.name)) {\n          if (ignoreAttribute(toAttribute.name, toEl, \"remove\", ctx)) {\n            continue;\n          }\n          toEl.removeAttribute(toAttribute.name);\n        }\n      }\n    }\n\n    // sync text nodes\n    if (type === 8 /* comment */ || type === 3 /* text */) {\n      if (to.nodeValue !== from.nodeValue) {\n        to.nodeValue = from.nodeValue;\n      }\n    }\n\n    if (!ignoreValueOfActiveElement(to, ctx)) {\n      // sync input values\n      syncInputValue(from, to, ctx);\n    }\n  }\n\n  /**\n   * @param {Element} from element to sync the value from\n   * @param {Element} to element to sync the value to\n   * @param {string} attributeName the attribute name\n   * @param {MorphContext} ctx the merge context\n   */\n  function syncBooleanAttribute(from, to, attributeName, ctx) {\n    // TODO: prefer set/getAttribute here\n    if (!(from instanceof Element && to instanceof Element)) return;\n    // @ts-ignore this function is only used on boolean attrs that are reflected as dom properties\n    const fromLiveValue = from[attributeName],\n      toLiveValue = to[attributeName];\n    if (fromLiveValue !== toLiveValue) {\n      let ignoreUpdate = ignoreAttribute(attributeName, to, \"update\", ctx);\n      if (!ignoreUpdate) {\n        // update attribute's associated DOM property\n        // @ts-ignore this function is only used on boolean attrs that are reflected as dom properties\n        to[attributeName] = from[attributeName];\n      }\n      if (fromLiveValue) {\n        if (!ignoreUpdate) {\n          // TODO: do we really want this? tests say so but it feels wrong\n          to.setAttribute(attributeName, fromLiveValue);\n        }\n      } else {\n        if (!ignoreAttribute(attributeName, to, \"remove\", ctx)) {\n          to.removeAttribute(attributeName);\n        }\n      }\n    }\n  }\n\n  /**\n   * NB: many bothans died to bring us information:\n   *\n   *  https://github.com/patrick-steele-idem/morphdom/blob/master/src/specialElHandlers.js\n   *  https://github.com/choojs/nanomorph/blob/master/lib/morph.jsL113\n   *\n   * @param {Node} from the element to sync the input value from\n   * @param {Node} to the element to sync the input value to\n   * @param {MorphContext} ctx the merge context\n   */\n  function syncInputValue(from, to, ctx) {\n    if (\n      from instanceof HTMLInputElement &&\n      to instanceof HTMLInputElement &&\n      from.type !== \"file\"\n    ) {\n      let fromValue = from.value;\n      let toValue = to.value;\n\n      // sync boolean attributes\n      syncBooleanAttribute(from, to, \"checked\", ctx);\n      syncBooleanAttribute(from, to, \"disabled\", ctx);\n\n      if (!from.hasAttribute(\"value\")) {\n        if (!ignoreAttribute(\"value\", to, \"remove\", ctx)) {\n          to.value = \"\";\n          to.removeAttribute(\"value\");\n        }\n      } else if (fromValue !== toValue) {\n        if (!ignoreAttribute(\"value\", to, \"update\", ctx)) {\n          to.setAttribute(\"value\", fromValue);\n          to.value = fromValue;\n        }\n      }\n      // TODO: QUESTION(1cg): this used to only check `from` unlike the other branches -- why?\n      // did I break something?\n    } else if (\n      from instanceof HTMLOptionElement &&\n      to instanceof HTMLOptionElement\n    ) {\n      syncBooleanAttribute(from, to, \"selected\", ctx);\n    } else if (\n      from instanceof HTMLTextAreaElement &&\n      to instanceof HTMLTextAreaElement\n    ) {\n      let fromValue = from.value;\n      let toValue = to.value;\n      if (ignoreAttribute(\"value\", to, \"update\", ctx)) {\n        return;\n      }\n      if (fromValue !== toValue) {\n        to.value = fromValue;\n      }\n      if (to.firstChild && to.firstChild.nodeValue !== fromValue) {\n        to.firstChild.nodeValue = fromValue;\n      }\n    }\n  }\n\n  /**\n   * =============================================================================\n   *  The HEAD tag can be handled specially, either w/ a 'merge' or 'append' style\n   * =============================================================================\n   * @param {Element} newHeadTag\n   * @param {Element} currentHead\n   * @param {MorphContext} ctx\n   * @returns {Promise<void>[]}\n   */\n  function handleHeadElement(newHeadTag, currentHead, ctx) {\n    /**\n     * @type {Node[]}\n     */\n    let added = [];\n    /**\n     * @type {Element[]}\n     */\n    let removed = [];\n    /**\n     * @type {Element[]}\n     */\n    let preserved = [];\n    /**\n     * @type {Element[]}\n     */\n    let nodesToAppend = [];\n\n    let headMergeStyle = ctx.head.style;\n\n    // put all new head elements into a Map, by their outerHTML\n    let srcToNewHeadNodes = new Map();\n    for (const newHeadChild of newHeadTag.children) {\n      srcToNewHeadNodes.set(newHeadChild.outerHTML, newHeadChild);\n    }\n\n    // for each elt in the current head\n    for (const currentHeadElt of currentHead.children) {\n      // If the current head element is in the map\n      let inNewContent = srcToNewHeadNodes.has(currentHeadElt.outerHTML);\n      let isReAppended = ctx.head.shouldReAppend(currentHeadElt);\n      let isPreserved = ctx.head.shouldPreserve(currentHeadElt);\n      if (inNewContent || isPreserved) {\n        if (isReAppended) {\n          // remove the current version and let the new version replace it and re-execute\n          removed.push(currentHeadElt);\n        } else {\n          // this element already exists and should not be re-appended, so remove it from\n          // the new content map, preserving it in the DOM\n          srcToNewHeadNodes.delete(currentHeadElt.outerHTML);\n          preserved.push(currentHeadElt);\n        }\n      } else {\n        if (headMergeStyle === \"append\") {\n          // we are appending and this existing element is not new content\n          // so if and only if it is marked for re-append do we do anything\n          if (isReAppended) {\n            removed.push(currentHeadElt);\n            nodesToAppend.push(currentHeadElt);\n          }\n        } else {\n          // if this is a merge, we remove this content since it is not in the new head\n          if (ctx.head.shouldRemove(currentHeadElt) !== false) {\n            removed.push(currentHeadElt);\n          }\n        }\n      }\n    }\n\n    // Push the remaining new head elements in the Map into the\n    // nodes to append to the head tag\n    nodesToAppend.push(...srcToNewHeadNodes.values());\n    log(\"to append: \", nodesToAppend);\n\n    let promises = [];\n    for (const newNode of nodesToAppend) {\n      log(\"adding: \", newNode);\n      // TODO: This could theoretically be null, based on type\n      let newElt = /** @type {ChildNode} */ (\n        document.createRange().createContextualFragment(newNode.outerHTML)\n          .firstChild\n      );\n      log(newElt);\n      if (ctx.callbacks.beforeNodeAdded(newElt) !== false) {\n        if (\n          (\"href\" in newElt && newElt.href) ||\n          (\"src\" in newElt && newElt.src)\n        ) {\n          /** @type {(result?: any) => void} */ let resolve;\n          let promise = new Promise(function (_resolve) {\n            resolve = _resolve;\n          });\n          newElt.addEventListener(\"load\", function () {\n            resolve();\n          });\n          promises.push(promise);\n        }\n        currentHead.appendChild(newElt);\n        ctx.callbacks.afterNodeAdded(newElt);\n        added.push(newElt);\n      }\n    }\n\n    // remove all removed elements, after we have appended the new elements to avoid\n    // additional network requests for things like style sheets\n    for (const removedElement of removed) {\n      if (ctx.callbacks.beforeNodeRemoved(removedElement) !== false) {\n        currentHead.removeChild(removedElement);\n        ctx.callbacks.afterNodeRemoved(removedElement);\n      }\n    }\n\n    ctx.head.afterHeadMorphed(currentHead, {\n      added: added,\n      kept: preserved,\n      removed: removed,\n    });\n    return promises;\n  }\n\n  //=============================================================================\n  // Misc\n  //=============================================================================\n\n  /**\n   * @param {any[]} _args\n   */\n  function log(..._args) {\n    //console.log(args);\n  }\n\n  function noOp() {}\n\n  /**\n   * Deep merges the config object and the Idiomoroph.defaults object to\n   * produce a final configuration object\n   * @param {Config} config\n   * @returns {ConfigInternal}\n   */\n  function mergeDefaults(config) {\n    /**\n     * @type {ConfigInternal}\n     */\n    let finalConfig = Object.assign({}, defaults);\n\n    // copy top level stuff into final config\n    Object.assign(finalConfig, config);\n\n    // copy callbacks into final config (do this to deep merge the callbacks)\n    finalConfig.callbacks = Object.assign(\n      {},\n      defaults.callbacks,\n      config.callbacks,\n    );\n\n    // copy head config into final config  (do this to deep merge the head)\n    finalConfig.head = Object.assign({}, defaults.head, config.head);\n\n    return finalConfig;\n  }\n\n  /**\n   *\n   * @param {Element} oldNode\n   * @param {Element} newContent\n   * @param {Config} config\n   * @returns {MorphContext}\n   */\n  function createMorphContext(oldNode, newContent, config) {\n    const mergedConfig = mergeDefaults(config);\n    return {\n      target: oldNode,\n      newContent: newContent,\n      config: mergedConfig,\n      morphStyle: mergedConfig.morphStyle,\n      ignoreActive: mergedConfig.ignoreActive,\n      ignoreActiveValue: mergedConfig.ignoreActiveValue,\n      idMap: createIdMap(oldNode, newContent),\n      deadIds: new Set(),\n      persistentIds: mergedConfig.twoPass\n        ? createPersistentIds(oldNode, newContent)\n        : new Set(),\n      pantry: mergedConfig.twoPass\n        ? createPantry()\n        : document.createElement(\"div\"),\n      callbacks: mergedConfig.callbacks,\n      head: mergedConfig.head,\n    };\n  }\n\n  function createPantry() {\n    const pantry = document.createElement(\"div\");\n    pantry.hidden = true;\n    document.body.insertAdjacentElement(\"afterend\", pantry);\n    return pantry;\n  }\n\n  /**\n   *\n   * @param {Node | null} node1\n   * @param {Node | null} node2\n   * @param {MorphContext} ctx\n   * @returns {boolean}\n   */\n  // TODO: The function handles this as if it's Element or null, but the function is called in\n  //   places where the arguments may be just a Node, not an Element\n  function isIdSetMatch(node1, node2, ctx) {\n    if (node1 == null || node2 == null) {\n      return false;\n    }\n    if (\n      node1 instanceof Element &&\n      node2 instanceof Element &&\n      node1.tagName === node2.tagName\n    ) {\n      if (node1.id !== \"\" && node1.id === node2.id) {\n        return true;\n      } else {\n        return getIdIntersectionCount(ctx, node1, node2) > 0;\n      }\n    }\n    return false;\n  }\n\n  /**\n   *\n   * @param {Node | null} oldNode\n   * @param {Node | null} newNode\n   * @returns {boolean}\n   */\n  function isSoftMatch(oldNode, newNode) {\n    if (oldNode == null || newNode == null) {\n      return false;\n    }\n    // ok to cast: if one is not element, `id` or `tagName` will be undefined and we'll compare that\n    // If oldNode has an `id` with possible state and it doesn't match newNode.id then avoid morphing\n    if (\n      /** @type {Element} */ (oldNode).id &&\n      /** @type {Element} */ (oldNode).id !==\n        /** @type {Element} */ (newNode).id\n    ) {\n      return false;\n    }\n    return (\n      oldNode.nodeType === newNode.nodeType &&\n      /** @type {Element} */ (oldNode).tagName ===\n        /** @type {Element} */ (newNode).tagName\n    );\n  }\n\n  /**\n   *\n   * @param {Node} startInclusive\n   * @param {Node} endExclusive\n   * @param {MorphContext} ctx\n   * @returns {Node | null}\n   */\n  function removeNodesBetween(startInclusive, endExclusive, ctx) {\n    /** @type {Node | null} */ let cursor = startInclusive;\n    while (cursor !== endExclusive) {\n      let tempNode = /** @type {Node} */ (cursor);\n      // TODO: Prefer assigning to a new variable here or expand the type of startInclusive\n      //  to be Node | null\n      cursor = tempNode.nextSibling;\n      removeNode(tempNode, ctx);\n    }\n    removeIdsFromConsideration(ctx, endExclusive);\n    return endExclusive.nextSibling;\n  }\n\n  /**\n   * =============================================================================\n   *  Scans forward from the insertionPoint in the old parent looking for a potential id match\n   *  for the newChild.  We stop if we find a potential id match for the new child OR\n   *  if the number of potential id matches we are discarding is greater than the\n   *  potential id matches for the new child\n   * =============================================================================\n   * @param {Node} newContent\n   * @param {Node} oldParent\n   * @param {Node} newChild\n   * @param {Node} insertionPoint\n   * @param {MorphContext} ctx\n   * @returns {null | Node}\n   */\n  function findIdSetMatch(\n    newContent,\n    oldParent,\n    newChild,\n    insertionPoint,\n    ctx,\n  ) {\n    // max id matches we are willing to discard in our search\n    let newChildPotentialIdCount = getIdIntersectionCount(\n      ctx,\n      newChild,\n      oldParent,\n    );\n\n    /**\n     * @type {Node | null}\n     */\n    let potentialMatch = null;\n\n    // only search forward if there is a possibility of an id match\n    if (newChildPotentialIdCount > 0) {\n      // TODO: This is ghosting the potentialMatch variable outside of this block.\n      //   Probably an error\n      potentialMatch = insertionPoint;\n      // if there is a possibility of an id match, scan forward\n      // keep track of the potential id match count we are discarding (the\n      // newChildPotentialIdCount must be greater than this to make it likely\n      // worth it)\n      let otherMatchCount = 0;\n      while (potentialMatch != null) {\n        // If we have an id match, return the current potential match\n        if (isIdSetMatch(newChild, potentialMatch, ctx)) {\n          return potentialMatch;\n        }\n\n        // computer the other potential matches of this new content\n        otherMatchCount += getIdIntersectionCount(\n          ctx,\n          potentialMatch,\n          newContent,\n        );\n        if (otherMatchCount > newChildPotentialIdCount) {\n          // if we have more potential id matches in _other_ content, we\n          // do not have a good candidate for an id match, so return null\n          return null;\n        }\n\n        // advanced to the next old content child\n        potentialMatch = potentialMatch.nextSibling;\n      }\n    }\n    return potentialMatch;\n  }\n\n  /**\n   * =============================================================================\n   *  Scans forward from the insertionPoint in the old parent looking for a potential soft match\n   *  for the newChild.  We stop if we find a potential soft match for the new child OR\n   *  if we find a potential id match in the old parents children OR if we find two\n   *  potential soft matches for the next two pieces of new content\n   * =============================================================================\n   * @param {Node} newContent\n   * @param {Node} oldParent\n   * @param {Node} newChild\n   * @param {Node} insertionPoint\n   * @param {MorphContext} ctx\n   * @returns {null | Node}\n   */\n  function findSoftMatch(newContent, oldParent, newChild, insertionPoint, ctx) {\n    /**\n     * @type {Node | null}\n     */\n    let potentialSoftMatch = insertionPoint;\n    /**\n     * @type {Node | null}\n     */\n    let nextSibling = newChild.nextSibling;\n    let siblingSoftMatchCount = 0;\n\n    while (potentialSoftMatch != null) {\n      if (getIdIntersectionCount(ctx, potentialSoftMatch, newContent) > 0) {\n        // the current potential soft match has a potential id set match with the remaining new\n        // content so bail out of looking\n        return null;\n      }\n\n      // if we have a soft match with the current node, return it\n      if (isSoftMatch(potentialSoftMatch, newChild)) {\n        return potentialSoftMatch;\n      }\n\n      if (isSoftMatch(potentialSoftMatch, nextSibling)) {\n        // the next new node has a soft match with this node, so\n        // increment the count of future soft matches\n        siblingSoftMatchCount++;\n        // ok to cast: if it was null it couldn't be a soft match\n        nextSibling = /** @type {Node} */ (nextSibling).nextSibling;\n\n        // If there are two future soft matches, bail to allow the siblings to soft match\n        // so that we don't consume future soft matches for the sake of the current node\n        if (siblingSoftMatchCount >= 2) {\n          return null;\n        }\n      }\n\n      // advanced to the next old content child\n      potentialSoftMatch = potentialSoftMatch.nextSibling;\n    }\n\n    return potentialSoftMatch;\n  }\n\n  /** @type {WeakSet<Node>} */\n  const generatedByIdiomorph = new WeakSet();\n\n  /**\n   *\n   * @param {string} newContent\n   * @returns {Node | null | DocumentFragment}\n   */\n  function parseContent(newContent) {\n    let parser = new DOMParser();\n\n    // remove svgs to avoid false-positive matches on head, etc.\n    let contentWithSvgsRemoved = newContent.replace(\n      /<svg(\\s[^>]*>|>)([\\s\\S]*?)<\\/svg>/gim,\n      \"\",\n    );\n\n    // if the newContent contains a html, head or body tag, we can simply parse it w/o wrapping\n    if (\n      contentWithSvgsRemoved.match(/<\\/html>/) ||\n      contentWithSvgsRemoved.match(/<\\/head>/) ||\n      contentWithSvgsRemoved.match(/<\\/body>/)\n    ) {\n      let content = parser.parseFromString(newContent, \"text/html\");\n      // if it is a full HTML document, return the document itself as the parent container\n      if (contentWithSvgsRemoved.match(/<\\/html>/)) {\n        generatedByIdiomorph.add(content);\n        return content;\n      } else {\n        // otherwise return the html element as the parent container\n        let htmlElement = content.firstChild;\n        if (htmlElement) {\n          generatedByIdiomorph.add(htmlElement);\n          return htmlElement;\n        } else {\n          return null;\n        }\n      }\n    } else {\n      // if it is partial HTML, wrap it in a template tag to provide a parent element and also to help\n      // deal with touchy tags like tr, tbody, etc.\n      let responseDoc = parser.parseFromString(\n        \"<body><template>\" + newContent + \"</template></body>\",\n        \"text/html\",\n      );\n      let content = /** @type {HTMLTemplateElement} */ (\n        responseDoc.body.querySelector(\"template\")\n      ).content;\n      generatedByIdiomorph.add(content);\n      return content;\n    }\n  }\n\n  /**\n   *\n   * @param {null | Node | HTMLCollection | Node[] | Document & {generatedByIdiomorph:boolean}} newContent\n   * @returns {Element}\n   */\n  function normalizeContent(newContent) {\n    if (newContent == null) {\n      // noinspection UnnecessaryLocalVariableJS\n      const dummyParent = document.createElement(\"div\");\n      return dummyParent;\n    } else if (generatedByIdiomorph.has(/** @type {Element} */ (newContent))) {\n      // the template tag created by idiomorph parsing can serve as a dummy parent\n      return /** @type {Element} */ (newContent);\n    } else if (newContent instanceof Node) {\n      // a single node is added as a child to a dummy parent\n      const dummyParent = document.createElement(\"div\");\n      dummyParent.append(newContent);\n      return dummyParent;\n    } else {\n      // all nodes in the array or HTMLElement collection are consolidated under\n      // a single dummy parent element\n      const dummyParent = document.createElement(\"div\");\n      for (const elt of [...newContent]) {\n        dummyParent.append(elt);\n      }\n      return dummyParent;\n    }\n  }\n\n  /**\n   *\n   * @param {Node | null} previousSibling\n   * @param {Node} morphedNode\n   * @param {Node | null} nextSibling\n   * @returns {Node[]}\n   */\n  function insertSiblings(previousSibling, morphedNode, nextSibling) {\n    /**\n     * @type {Node[]}\n     */\n    let stack = [];\n    /**\n     * @type {Node[]}\n     */\n    let added = [];\n    while (previousSibling != null) {\n      stack.push(previousSibling);\n      previousSibling = previousSibling.previousSibling;\n    }\n    // Base the loop on the node variable, so that you do not need runtime checks for\n    // undefined value inside the loop\n    let node = stack.pop();\n    while (node !== undefined) {\n      added.push(node); // push added preceding siblings on in order and insert\n      morphedNode.parentElement?.insertBefore(node, morphedNode);\n      node = stack.pop();\n    }\n    added.push(morphedNode);\n    while (nextSibling != null) {\n      stack.push(nextSibling);\n      added.push(nextSibling); // here we are going in order, so push on as we scan, rather than add\n      nextSibling = nextSibling.nextSibling;\n    }\n    while (stack.length > 0) {\n      const node = /** @type {Node} */ (stack.pop());\n      morphedNode.parentElement?.insertBefore(node, morphedNode.nextSibling);\n    }\n    return added;\n  }\n\n  /**\n   *\n   * @param {Element} newContent\n   * @param {Element} oldNode\n   * @param {MorphContext} ctx\n   * @returns {Node | null}\n   */\n  function findBestNodeMatch(newContent, oldNode, ctx) {\n    /**\n     * @type {Node | null}\n     */\n    let currentElement;\n    currentElement = newContent.firstChild;\n    /**\n     * @type {Node | null}\n     */\n    let bestElement = currentElement;\n    let score = 0;\n    while (currentElement) {\n      let newScore = scoreElement(currentElement, oldNode, ctx);\n      if (newScore > score) {\n        bestElement = currentElement;\n        score = newScore;\n      }\n      currentElement = currentElement.nextSibling;\n    }\n    return bestElement;\n  }\n\n  /**\n   *\n   * @param {Node | null} node1\n   * @param {Element} node2\n   * @param {MorphContext} ctx\n   * @returns {number}\n   */\n  // TODO: The function handles node1 and node2 as if they are Elements but the function is\n  //   called in places where node1 and node2 may be just Nodes, not Elements\n  function scoreElement(node1, node2, ctx) {\n    if (isSoftMatch(node2, node1)) {\n      // ok to cast: isSoftMatch performs a null check\n      return (\n        0.5 + getIdIntersectionCount(ctx, /** @type {Node} */ (node1), node2)\n      );\n    }\n    return 0;\n  }\n\n  /**\n   *\n   * @param {Node} tempNode\n   * @param {MorphContext} ctx\n   */\n  // TODO: The function handles tempNode as if it's Element but the function is called in\n  //   places where tempNode may be just a Node, not an Element\n  function removeNode(tempNode, ctx) {\n    removeIdsFromConsideration(ctx, tempNode);\n    // skip remove callbacks when we're going to be restoring this from the pantry in the second pass\n    if (\n      ctx.config.twoPass &&\n      hasPersistentIdNodes(ctx, tempNode) &&\n      tempNode instanceof Element\n    ) {\n      moveToPantry(tempNode, ctx);\n    } else {\n      if (ctx.callbacks.beforeNodeRemoved(tempNode) === false) return;\n      tempNode.parentNode?.removeChild(tempNode);\n      ctx.callbacks.afterNodeRemoved(tempNode);\n    }\n  }\n\n  /**\n   *\n   * @param {Node} node\n   * @param {MorphContext} ctx\n   */\n  function moveToPantry(node, ctx) {\n    if (ctx.callbacks.beforeNodePantried(node) === false) return;\n\n    Array.from(node.childNodes).forEach((child) => {\n      moveToPantry(child, ctx);\n    });\n\n    // After processing children, process the current node\n    if (ctx.persistentIds.has(/** @type {Element} */ (node).id)) {\n      // @ts-ignore - use proposed moveBefore feature\n      if (ctx.pantry.moveBefore) {\n        // @ts-ignore - use proposed moveBefore feature\n        ctx.pantry.moveBefore(node, null);\n      } else {\n        ctx.pantry.insertBefore(node, null);\n      }\n    } else {\n      if (ctx.callbacks.beforeNodeRemoved(node) === false) return;\n      node.parentNode?.removeChild(node);\n      ctx.callbacks.afterNodeRemoved(node);\n    }\n  }\n\n  /**\n   *\n   * @param {Node | null} root\n   * @param {MorphContext} ctx\n   */\n  function restoreFromPantry(root, ctx) {\n    if (root instanceof Element) {\n      Array.from(ctx.pantry.children)\n        .reverse()\n        .forEach((element) => {\n          const matchElement = root.querySelector(`#${element.id}`);\n          if (matchElement) {\n            // @ts-ignore - use proposed moveBefore feature\n            if (matchElement.parentElement?.moveBefore) {\n              // @ts-ignore - use proposed moveBefore feature\n              matchElement.parentElement.moveBefore(element, matchElement);\n              while (matchElement.hasChildNodes()) {\n                // @ts-ignore - use proposed moveBefore feature\n                element.moveBefore(matchElement.firstChild, null);\n              }\n            } else {\n              matchElement.before(element);\n              while (matchElement.firstChild) {\n                element.insertBefore(matchElement.firstChild, null);\n              }\n            }\n            if (\n              ctx.callbacks.beforeNodeMorphed(element, matchElement) !== false\n            ) {\n              syncNodeFrom(matchElement, element, ctx);\n              ctx.callbacks.afterNodeMorphed(element, matchElement);\n            }\n            matchElement.remove();\n          }\n        });\n      ctx.pantry.remove();\n    }\n  }\n\n  //=============================================================================\n  // ID Set Functions\n  //=============================================================================\n\n  /**\n   *\n   * @param {MorphContext} ctx\n   * @param {string} id\n   * @returns {boolean}\n   */\n  function isIdInConsideration(ctx, id) {\n    return !ctx.deadIds.has(id);\n  }\n\n  /**\n   *\n   * @param {MorphContext} ctx\n   * @param {string} id\n   * @param {Node} targetNode\n   * @returns {boolean}\n   */\n  function idIsWithinNode(ctx, id, targetNode) {\n    let idSet = ctx.idMap.get(targetNode) || EMPTY_SET;\n    return idSet.has(id);\n  }\n\n  /**\n   *\n   * @param {MorphContext} ctx\n   * @param {Node} node\n   * @returns {void}\n   */\n  function removeIdsFromConsideration(ctx, node) {\n    let idSet = ctx.idMap.get(node) || EMPTY_SET;\n    for (const id of idSet) {\n      ctx.deadIds.add(id);\n    }\n  }\n\n  /**\n   *\n   * @param {MorphContext} ctx\n   * @param {Node} node\n   * @returns {boolean}\n   */\n  function hasPersistentIdNodes(ctx, node) {\n    for (const id of ctx.idMap.get(node) || EMPTY_SET) {\n      if (ctx.persistentIds.has(id)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   *\n   * @param {MorphContext} ctx\n   * @param {Node} node1\n   * @param {Node} node2\n   * @returns {number}\n   */\n  function getIdIntersectionCount(ctx, node1, node2) {\n    let sourceSet = ctx.idMap.get(node1) || EMPTY_SET;\n    let matchCount = 0;\n    for (const id of sourceSet) {\n      // a potential match is an id in the source and potentialIdsSet, but\n      // that has not already been merged into the DOM\n      if (isIdInConsideration(ctx, id) && idIsWithinNode(ctx, id, node2)) {\n        ++matchCount;\n      }\n    }\n    return matchCount;\n  }\n\n  /**\n   * @param {Element} content\n   * @returns {Element[]}\n   */\n  function nodesWithIds(content) {\n    let nodes = Array.from(content.querySelectorAll(\"[id]\"));\n    if (content.id) {\n      nodes.push(content);\n    }\n    return nodes;\n  }\n\n  /**\n   * A bottom up algorithm that finds all elements with ids in the node\n   * argument and populates id sets for those nodes and all their parents, generating\n   * a set of ids contained within all nodes for the entire hierarchy in the DOM\n   *\n   * @param {Element} node\n   * @param {Map<Node, Set<string>>} idMap\n   */\n  function populateIdMapForNode(node, idMap) {\n    let nodeParent = node.parentElement;\n    for (const elt of nodesWithIds(node)) {\n      /**\n       * @type {Element|null}\n       */\n      let current = elt;\n      // walk up the parent hierarchy of that element, adding the id\n      // of element to the parent's id set\n      while (current !== nodeParent && current != null) {\n        let idSet = idMap.get(current);\n        // if the id set doesn't exist, create it and insert it in the  map\n        if (idSet == null) {\n          idSet = new Set();\n          idMap.set(current, idSet);\n        }\n        idSet.add(elt.id);\n        current = current.parentElement;\n      }\n    }\n  }\n\n  /**\n   * This function computes a map of nodes to all ids contained within that node (inclusive of the\n   * node).  This map can be used to ask if two nodes have intersecting sets of ids, which allows\n   * for a looser definition of \"matching\" than tradition id matching, and allows child nodes\n   * to contribute to a parent nodes matching.\n   *\n   * @param {Element} oldContent  the old content that will be morphed\n   * @param {Element} newContent  the new content to morph to\n   * @returns {Map<Node, Set<string>>} a map of nodes to id sets for the\n   */\n  function createIdMap(oldContent, newContent) {\n    /**\n     *\n     * @type {Map<Node, Set<string>>}\n     */\n    let idMap = new Map();\n    populateIdMapForNode(oldContent, idMap);\n    populateIdMapForNode(newContent, idMap);\n    return idMap;\n  }\n\n  /**\n   * @param {Element} oldContent  the old content that will be morphed\n   * @param {Element} newContent  the new content to morph to\n   * @returns {Set<string>} the id set of all persistent nodes that exist in both old and new content\n   */\n  function createPersistentIds(oldContent, newContent) {\n    const toIdTagName = (node) => node.tagName + \"#\" + node.id;\n    const oldIdSet = new Set(nodesWithIds(oldContent).map(toIdTagName));\n\n    let matchIdSet = new Set();\n    for (const newNode of nodesWithIds(newContent)) {\n      if (oldIdSet.has(toIdTagName(newNode))) {\n        matchIdSet.add(newNode.id);\n      }\n    }\n    return matchIdSet;\n  }\n\n  //=============================================================================\n  // This is what ends up becoming the Idiomorph global object\n  //=============================================================================\n  return {\n    morph,\n    defaults,\n  };\n})();\n\nexport {Idiomorph};\n", "import { log } from \"../logger.js\";\nimport { cacheBustedUrl, reloadHtmlDocument } from \"../helpers.js\";\n\nexport class StimulusReloader {\n  static async reload(changedFilePath) {\n    const document = await reloadHtmlDocument();\n    return new StimulusReloader(document, changedFilePath).reload();\n  }\n\n  static async reloadAll() {\n    Stimulus.controllers.forEach((controller) => {\n      Stimulus.unload(controller.identifier);\n      Stimulus.register(controller.identifier, controller.constructor);\n    });\n\n    return Promise.resolve();\n  }\n\n  constructor(document, changedFilePath) {\n    this.document = document;\n    this.changedFilePath = changedFilePath;\n    this.application = window.Stimulus;\n  }\n\n  async reload() {\n    log(\"Reload Stimulus controllers...\");\n\n    this.application.stop();\n\n    await this.#reloadChangedStimulusControllers();\n    this.#unloadDeletedStimulusControllers();\n\n    this.application.start();\n  }\n\n  async #reloadChangedStimulusControllers() {\n    await Promise.all(\n      this.#stimulusControllerPathsToReload.map(async (moduleName) =>\n        this.#reloadStimulusController(moduleName),\n      ),\n    );\n  }\n\n  get #stimulusControllerPathsToReload() {\n    this.controllerPathsToReload =\n      this.controllerPathsToReload ||\n      this.#stimulusControllerPaths.filter((path) =>\n        this.#shouldReloadController(path),\n      );\n    return this.controllerPathsToReload;\n  }\n\n  get #stimulusControllerPaths() {\n    return Object.keys(this.#stimulusPathsByModule).filter((path) =>\n      path.endsWith(\"_controller\"),\n    );\n  }\n\n  #shouldReloadController(path) {\n    return (\n      this.#extractControllerName(path) === this.#changedControllerIdentifier\n    );\n  }\n\n  get #changedControllerIdentifier() {\n    this.changedControllerIdentifier =\n      this.changedControllerIdentifier ||\n      this.#extractControllerName(this.changedFilePath);\n    return this.changedControllerIdentifier;\n  }\n\n  get #stimulusPathsByModule() {\n    this.pathsByModule = this.pathsByModule || this.#parseImportmapJson();\n    return this.pathsByModule;\n  }\n\n  #parseImportmapJson() {\n    const importmapScript = this.document.querySelector(\n      \"script[type=importmap]\",\n    );\n    return JSON.parse(importmapScript.text).imports;\n  }\n\n  async #reloadStimulusController(moduleName) {\n    log(`\\t${moduleName}`);\n\n    const controllerName = this.#extractControllerName(moduleName);\n    const path = cacheBustedUrl(this.#pathForModuleName(moduleName));\n\n    const module = await import(path);\n\n    this.#registerController(controllerName, module);\n  }\n\n  #unloadDeletedStimulusControllers() {\n    this.#controllersToUnload.forEach((controller) =>\n      this.#deregisterController(controller.identifier),\n    );\n  }\n\n  get #controllersToUnload() {\n    if (this.#didChangeTriggerAReload) {\n      return [];\n    } else {\n      return this.application.controllers.filter(\n        (controller) =>\n          this.#changedControllerIdentifier === controller.identifier,\n      );\n    }\n  }\n\n  get #didChangeTriggerAReload() {\n    return this.#stimulusControllerPathsToReload.length > 0;\n  }\n\n  #pathForModuleName(moduleName) {\n    return this.#stimulusPathsByModule[moduleName];\n  }\n\n  #extractControllerName(path) {\n    return path\n      .replace(/^\\/+/, \"\")\n      .replace(/^controllers\\//, \"\")\n      .replace(\"_controller\", \"\")\n      .replace(/\\//g, \"--\")\n      .replace(/_/g, \"-\")\n      .replace(/\\.js$/, \"\");\n  }\n\n  #registerController(name, module) {\n    this.application.unload(name);\n    this.application.register(name, module.default);\n  }\n\n  #deregisterController(name) {\n    log(`\\tRemoving controller ${name}`);\n    this.application.unload(name);\n  }\n}\n", "import { reloadHtmlDocument } from \"../helpers.js\";\nimport { log } from \"../logger.js\";\nimport { Idiomorph } from \"idiomorph/dist/idiomorph.esm.js\";\nimport { StimulusReloader } from \"./stimulus_reloader.js\";\n\nexport class MorphHtmlReloader {\n  static async reload() {\n    return new MorphHtmlReloader().reload();\n  }\n\n  async reload() {\n    await this.#reloadHtml();\n    await this.#reloadStimulus();\n  }\n\n  async #reloadHtml() {\n    log(\"Reload HTML...\");\n\n    const reloadedDocument = await reloadHtmlDocument();\n    this.#updateBody(reloadedDocument.body);\n    return reloadedDocument;\n  }\n\n  #updateBody(newBody) {\n    Idiomorph.morph(document.body, newBody);\n  }\n\n  async #reloadStimulus() {\n    await StimulusReloader.reloadAll();\n  }\n}\n", "import { log } from \"../logger.js\";\nimport {\n  cacheBustedUrl,\n  reloadHtmlDocument,\n  pathWithoutAssetDigest,\n} from \"../helpers.js\";\n\nexport class CssReloader {\n  static async reload(...params) {\n    return new CssReloader(...params).reload();\n  }\n\n  constructor(filePattern = /./) {\n    this.filePattern = filePattern;\n  }\n\n  async reload() {\n    log(\"Reload css...\");\n    await Promise.all(await this.#reloadAllLinks());\n  }\n\n  async #reloadAllLinks() {\n    const cssLinks = await this.#loadNewCssLinks();\n    return cssLinks.map((link) => this.#reloadLinkIfNeeded(link));\n  }\n\n  async #loadNewCssLinks() {\n    const reloadedDocument = await reloadHtmlDocument();\n    return Array.from(\n      reloadedDocument.head.querySelectorAll(\"link[rel='stylesheet']\"),\n    );\n  }\n\n  #reloadLinkIfNeeded(link) {\n    if (this.#shouldReloadLink(link)) {\n      return this.#reloadLink(link);\n    } else {\n      return Promise.resolve();\n    }\n  }\n\n  #shouldReloadLink(link) {\n    return this.filePattern.test(link.getAttribute(\"href\"));\n  }\n\n  async #reloadLink(link) {\n    return new Promise((resolve) => {\n      const href = link.getAttribute(\"href\");\n      const newLink =\n        this.#findExistingLinkFor(link) || this.#appendNewLink(link);\n\n      newLink.setAttribute(\"href\", cacheBustedUrl(link.getAttribute(\"href\")));\n      newLink.onload = () => {\n        log(`\\t${href}`);\n        resolve();\n      };\n    });\n  }\n\n  #findExistingLinkFor(link) {\n    return this.#cssLinks.find(\n      (newLink) =>\n        pathWithoutAssetDigest(link.href) ===\n        pathWithoutAssetDigest(newLink.href),\n    );\n  }\n\n  get #cssLinks() {\n    return Array.from(document.querySelectorAll(\"link[rel='stylesheet']\"));\n  }\n\n  #appendNewLink(link) {\n    document.head.append(link);\n    return link;\n  }\n}\n", "import { ReplaceHtmlReloader } from \"../reloaders/replace_html_reloader.js\";\nimport { MorphHtmlReloader } from \"../reloaders/morph_html_reloader.js\";\nimport { StimulusReloader } from \"../reloaders/stimulus_reloader.js\";\nimport { CssReloader } from \"../reloaders/css_reloader.js\";\n\nexport class ServerSentEventsChannel {\n  static async start() {\n    const sse = new EventSource(\"/hotwired-laravel-hotreload/sse\");\n\n    sse.addEventListener(\"reload_html\", (event) => {\n      const reloader =\n        HotwireHotreload.config.htmlReloadMethod === \"morph\"\n          ? MorphHtmlReloader\n          : ReplaceHtmlReloader;\n\n      return reloader.reload();\n    });\n\n    sse.addEventListener(\"reload_stimulus\", (event) => {\n      const data = JSON.parse(event.data);\n      return StimulusReloader.reload(data.path);\n    });\n\n    sse.addEventListener(\"reload_css\", (event) => {\n      const data = JSON.parse(event.data);\n      return CssReloader.reload(data.path);\n    });\n  }\n}\n", "import { ServerSentEventsChannel } from \"./channels\";\nimport { getConfigurationProperty } from \"./helpers.js\";\n\nconst HotwireHotreloadDefaultConfigs = {\n  loggingEnabled: false,\n  htmlReloadMethod: \"morph\",\n};\n\nconst HotwireHotreload = {\n  config: { ...HotwireHotreloadDefaultConfigs },\n};\n\nwindow.HotwireHotreload = HotwireHotreload;\n\nconst configProperties = {\n  loggingEnabled: \"logging\",\n  htmlReloadMethod: \"html-reload-method\",\n};\n\nconst syncConfigs = async () => {\n  Object.entries(configProperties).forEach(([key, property]) => {\n    HotwireHotreload.config[key] =\n      getConfigurationProperty(property) ?? HotwireHotreloadDefaultConfigs[key];\n  });\n};\n\ndocument.addEventListener(\"DOMContentLoaded\", async () => {\n  await syncConfigs();\n\n  await ServerSentEventsChannel.start();\n});\n\ndocument.addEventListener(\"turbo:load\", async () => {\n  await syncConfigs();\n});\n\nexport default HotwireHotreload;\n"],
  "mappings": "MAEO,SAASA,KAAOC,EAAU,CAC3BC,EAAiB,OAAO,gBAC1B,QAAQ,IAAI,sBAAuB,GAAGD,CAAQ,CAElD,CCJO,IAAME,EAAN,KAA0B,CAC/B,aAAa,QAAS,CACpB,OAAO,IAAIA,EAAoB,EAAE,OAAO,CAC1C,CAEA,MAAM,QAAS,CACb,MAAM,KAAKC,GAAY,CACzB,CAEA,KAAMA,IAAc,CAClBC,EAAI,2BAA2B,EAE/B,KAAKC,GAAoB,EACzB,MAAM,KAAKC,GAAkB,CAC/B,CAEAD,IAAsB,CACpB,SAAS,iBACP,sBACA,IAAM,CACJ,MAAM,UAAU,aAAa,SAAW,EAC1C,EACA,CAAE,KAAM,EAAK,CACf,CACF,CAEAC,IAAoB,CAClB,OAAO,IAAI,QAASC,GAAY,CAC9B,SAAS,iBAAiB,aAAc,IAAMA,EAAQ,QAAQ,EAAG,CAC/D,KAAM,EACR,CAAC,EACD,OAAO,MAAM,MAAM,MAAM,EACzB,OAAO,MAAM,MAAM,OAAO,QAAQ,CACpC,CAAC,CACH,CACF,ECjCO,SAASC,EAAuBC,EAAM,CAC3C,OAAOA,EAAK,QAAQ,4BAA6B,KAAK,CACxD,CAEO,SAASC,EAAcC,EAAWC,EAAQ,CAC/C,IAAMC,EAAM,IAAI,IAAIF,EAAW,OAAO,SAAS,MAAM,EAErD,cAAO,QAAQC,CAAM,EAAE,QAAQ,CAAC,CAACE,EAAKC,CAAK,IAAM,CAC/CF,EAAI,aAAa,IAAIC,EAAKC,CAAK,CACjC,CAAC,EAEMF,EAAI,SAAS,CACtB,CAEO,SAASG,EAAeL,EAAW,CACxC,OAAOD,EAAcC,EAAW,CAAE,OAAQ,KAAK,IAAI,CAAE,CAAC,CACxD,CAEA,eAAsBM,GAAqB,CACzC,IAAIC,EAAaF,EACfN,EAAc,OAAO,SAAS,KAAM,CAAE,cAAe,MAAO,CAAC,CAC/D,EAEMS,EAAW,MAAM,MAAMD,EAAY,CACvC,QAAS,CAAE,OAAQ,WAAY,CACjC,CAAC,EAED,GAAI,CAACC,EAAS,GACZ,MAAM,IAAI,MAAM,GAAGA,EAAS,wBAAwBD,GAAY,EAGlE,IAAME,EAAc,MAAMD,EAAS,KAAK,EAExC,OADe,IAAI,UAAU,EACf,gBAAgBC,EAAa,WAAW,CACxD,CAEO,SAASC,EAAyBC,EAAM,CAC7C,OAAO,SAAS,cAAc,gCAAgCA,KAAQ,GAClE,OACN,CCgDA,IAAIC,EAAa,UAAY,CAC3B,aA2BA,IAAIC,EAAY,IAAI,IAMhBC,EAAW,CACb,WAAY,YACZ,UAAW,CACT,gBAAiBC,EACjB,eAAgBA,EAChB,kBAAmBA,EACnB,iBAAkBA,EAClB,kBAAmBA,EACnB,iBAAkBA,EAClB,uBAAwBA,EACxB,mBAAoBA,CACtB,EACA,KAAM,CACJ,MAAO,QACP,eAAgB,SAAUC,EAAK,CAC7B,OAAOA,EAAI,aAAa,aAAa,IAAM,MAC7C,EACA,eAAgB,SAAUA,EAAK,CAC7B,OAAOA,EAAI,aAAa,cAAc,IAAM,MAC9C,EACA,aAAcD,EACd,iBAAkBA,CACpB,CACF,EAYA,SAASE,EAAMC,EAASC,EAAYC,EAAS,CAAC,EAAG,CAC3CF,aAAmB,WACrBA,EAAUA,EAAQ,iBAGhB,OAAOC,GAAe,WACxBA,EAAaE,GAAaF,CAAU,GAGtC,IAAIG,EAAoBC,GAAiBJ,CAAU,EAE/CK,EAAMC,GAAmBP,EAASI,EAAmBF,CAAM,EAE/D,OAAOM,EAAuBR,EAASI,EAAmBE,CAAG,CAC/D,CASA,SAASE,EAAuBR,EAASS,EAAsBH,EAAK,CAClE,GAAIA,EAAI,KAAK,MAAO,CAClB,IAAII,EAAUV,EAAQ,cAAc,MAAM,EACtCW,EAAUF,EAAqB,cAAc,MAAM,EACvD,GAAIC,GAAWC,EAAS,CACtB,IAAIC,EAAWC,EAAkBF,EAASD,EAASJ,CAAG,EAEtD,QAAQ,IAAIM,CAAQ,EAAE,KAAK,UAAY,CACrCJ,EACER,EACAS,EACA,OAAO,OAAOH,EAAK,CACjB,KAAM,CACJ,MAAO,GACP,OAAQ,EACV,CACF,CAAC,CACH,CACF,CAAC,EACD,MACF,CACF,CAEA,GAAIA,EAAI,aAAe,YAErB,OAAAQ,EAAcL,EAAsBT,EAASM,CAAG,EAC5CA,EAAI,OAAO,SACbS,EAAkBf,EAASM,CAAG,EAEzB,MAAM,KAAKN,EAAQ,QAAQ,EAC7B,GAAIM,EAAI,aAAe,aAAeA,EAAI,YAAc,KAAM,CAGnE,IAAIU,EAAYC,GAAkBR,EAAsBT,EAASM,CAAG,EAGhEY,EAAkBF,GAAW,iBAAmB,KAChDG,EAAcH,GAAW,aAAe,KAGxCI,EAAcC,EAAerB,EAASgB,EAAWV,CAAG,EAExD,GAAIU,GAGF,GAAII,EAAa,CACf,IAAME,EAAWC,GACfL,EACAE,EACAD,CACF,EACA,OAAIb,EAAI,OAAO,SACbS,EAAkBK,EAAY,WAAYd,CAAG,EAExCgB,CACT,MAGA,OAAO,CAAC,CAEZ,KACE,MAAM,wCAA0ChB,EAAI,UAExD,CAWA,SAASkB,EAA2BC,EAAuBnB,EAAK,CAC9D,MACE,CAAC,CAACA,EAAI,mBACNmB,IAA0B,SAAS,eACnCA,IAA0B,SAAS,IAEvC,CAQA,SAASJ,EAAerB,EAASC,EAAYK,EAAK,CAChD,OAAIA,EAAI,cAAgBN,IAAY,SAAS,cAyCtC,KAvCIC,GAAc,KACnBK,EAAI,UAAU,kBAAkBN,CAAO,IAAM,GAAcA,GAE/DA,EAAQ,YAAY,YAAYA,CAAO,EACvCM,EAAI,UAAU,iBAAiBN,CAAO,EAC/B,MACG0B,EAAY1B,EAASC,CAAU,GASrCK,EAAI,UAAU,kBAAkBN,EAASC,CAAU,IAAM,KAGzDD,aAAmB,iBAAmBM,EAAI,KAAK,SAGjDN,aAAmB,iBACnBM,EAAI,KAAK,QAAU,QAGnBO,EACkCZ,EAChCD,EACAM,CACF,GAEAqB,EAAa1B,EAAYD,EAASM,CAAG,EAChCkB,EAA2BxB,EAASM,CAAG,GAC1CQ,EAAcb,EAAYD,EAASM,CAAG,IAG1CA,EAAI,UAAU,iBAAiBN,EAASC,CAAU,GAC3CD,GA9BHM,EAAI,UAAU,kBAAkBN,CAAO,IAAM,IAC7CM,EAAI,UAAU,gBAAgBL,CAAU,IAAM,GAAcD,GAEhEA,EAAQ,YAAY,aAAaC,EAAYD,CAAO,EACpDM,EAAI,UAAU,eAAeL,CAAU,EACvCK,EAAI,UAAU,iBAAiBN,CAAO,EAC/BC,EA2BX,CAyBA,SAASa,EAAcc,EAAWC,EAAWvB,EAAK,CAE9CsB,aAAqB,qBACrBC,aAAqB,sBAErBD,EAAYA,EAAU,QACtBC,EAAYA,EAAU,SAOxB,IAAIC,EAAeF,EAAU,WAKzBG,EAAiBF,EAAU,WAC3BG,EAGJ,KAAOF,GAAc,CAKnB,GAJAE,EAAWF,EACXA,EAAeE,EAAS,YAGpBD,GAAkB,KAAM,CAE1B,GACEzB,EAAI,OAAO,SACXA,EAAI,cAAc,IAA4B0B,EAAU,EAAE,EAE1DH,EAAU,YAAYG,CAAQ,MACzB,CACL,GAAI1B,EAAI,UAAU,gBAAgB0B,CAAQ,IAAM,GAAO,SACvDH,EAAU,YAAYG,CAAQ,EAC9B1B,EAAI,UAAU,eAAe0B,CAAQ,CACvC,CACAC,EAA2B3B,EAAK0B,CAAQ,EACxC,QACF,CAGA,GAAIE,EAAaF,EAAUD,EAAgBzB,CAAG,EAAG,CAC/Ce,EAAeU,EAAgBC,EAAU1B,CAAG,EAC5CyB,EAAiBA,EAAe,YAChCE,EAA2B3B,EAAK0B,CAAQ,EACxC,QACF,CAGA,IAAIG,EAAaC,GACfR,EACAC,EACAG,EACAD,EACAzB,CACF,EAGA,GAAI6B,EAAY,CACdJ,EAAiBM,EAAmBN,EAAgBI,EAAY7B,CAAG,EACnEe,EAAec,EAAYH,EAAU1B,CAAG,EACxC2B,EAA2B3B,EAAK0B,CAAQ,EACxC,QACF,CAGA,IAAIM,EAAYC,GACdX,EACAC,EACAG,EACAD,EACAzB,CACF,EAGA,GAAIgC,EAAW,CACbP,EAAiBM,EAAmBN,EAAgBO,EAAWhC,CAAG,EAClEe,EAAeiB,EAAWN,EAAU1B,CAAG,EACvC2B,EAA2B3B,EAAK0B,CAAQ,EACxC,QACF,CAMA,GACE1B,EAAI,OAAO,SACXA,EAAI,cAAc,IAA4B0B,EAAU,EAAE,EAE1DH,EAAU,aAAaG,EAAUD,CAAc,MAC1C,CACL,GAAIzB,EAAI,UAAU,gBAAgB0B,CAAQ,IAAM,GAAO,SACvDH,EAAU,aAAaG,EAAUD,CAAc,EAC/CzB,EAAI,UAAU,eAAe0B,CAAQ,CACvC,CACAC,EAA2B3B,EAAK0B,CAAQ,CAC1C,CAGA,KAAOD,IAAmB,MAAM,CAC9B,IAAIS,EAAWT,EACfA,EAAiBA,EAAe,YAChCU,EAAWD,EAAUlC,CAAG,CAC1B,CACF,CAaA,SAASoC,EAAgBC,EAAMC,EAAIC,EAAYvC,EAAK,CAClD,OACEqC,IAAS,SACTrC,EAAI,mBACJsC,IAAO,SAAS,cAET,GAEFtC,EAAI,UAAU,uBAAuBqC,EAAMC,EAAIC,CAAU,IAAM,EACxE,CAUA,SAASlB,EAAamB,EAAMF,EAAItC,EAAK,CACnC,IAAIyC,EAAOD,EAAK,SAIhB,GAAIC,IAAS,EAAsB,CACjC,IAAMC,EAAiCF,EACjCG,EAA+BL,EAC/BM,EAAiBF,EAAO,WACxBG,EAAeF,EAAK,WAC1B,QAAWG,KAAiBF,EACtBR,EAAgBU,EAAc,KAAMH,EAAM,SAAU3C,CAAG,GAGvD2C,EAAK,aAAaG,EAAc,IAAI,IAAMA,EAAc,OAC1DH,EAAK,aAAaG,EAAc,KAAMA,EAAc,KAAK,EAI7D,QAASC,EAAIF,EAAa,OAAS,EAAG,GAAKE,EAAGA,IAAK,CACjD,IAAMC,EAAcH,EAAaE,GAIjC,GAAI,EAACC,GAED,CAACN,EAAO,aAAaM,EAAY,IAAI,EAAG,CAC1C,GAAIZ,EAAgBY,EAAY,KAAML,EAAM,SAAU3C,CAAG,EACvD,SAEF2C,EAAK,gBAAgBK,EAAY,IAAI,CACvC,CACF,CACF,EAGIP,IAAS,GAAmBA,IAAS,IACnCH,EAAG,YAAcE,EAAK,YACxBF,EAAG,UAAYE,EAAK,WAInBtB,EAA2BoB,EAAItC,CAAG,GAErCiD,GAAeT,EAAMF,EAAItC,CAAG,CAEhC,CAQA,SAASkD,EAAqBV,EAAMF,EAAIa,EAAenD,EAAK,CAE1D,GAAI,EAAEwC,aAAgB,SAAWF,aAAc,SAAU,OAEzD,IAAMc,EAAgBZ,EAAKW,GACzBE,EAAcf,EAAGa,GACnB,GAAIC,IAAkBC,EAAa,CACjC,IAAIC,EAAelB,EAAgBe,EAAeb,EAAI,SAAUtC,CAAG,EAC9DsD,IAGHhB,EAAGa,GAAiBX,EAAKW,IAEvBC,EACGE,GAEHhB,EAAG,aAAaa,EAAeC,CAAa,EAGzChB,EAAgBe,EAAeb,EAAI,SAAUtC,CAAG,GACnDsC,EAAG,gBAAgBa,CAAa,CAGtC,CACF,CAYA,SAASF,GAAeT,EAAMF,EAAItC,EAAK,CACrC,GACEwC,aAAgB,kBAChBF,aAAc,kBACdE,EAAK,OAAS,OACd,CACA,IAAIe,EAAYf,EAAK,MACjBgB,EAAUlB,EAAG,MAGjBY,EAAqBV,EAAMF,EAAI,UAAWtC,CAAG,EAC7CkD,EAAqBV,EAAMF,EAAI,WAAYtC,CAAG,EAEzCwC,EAAK,aAAa,OAAO,EAKnBe,IAAcC,IAClBpB,EAAgB,QAASE,EAAI,SAAUtC,CAAG,IAC7CsC,EAAG,aAAa,QAASiB,CAAS,EAClCjB,EAAG,MAAQiB,IAPRnB,EAAgB,QAASE,EAAI,SAAUtC,CAAG,IAC7CsC,EAAG,MAAQ,GACXA,EAAG,gBAAgB,OAAO,EAUhC,SACEE,aAAgB,mBAChBF,aAAc,kBAEdY,EAAqBV,EAAMF,EAAI,WAAYtC,CAAG,UAE9CwC,aAAgB,qBAChBF,aAAc,oBACd,CACA,IAAIiB,EAAYf,EAAK,MACjBgB,EAAUlB,EAAG,MACjB,GAAIF,EAAgB,QAASE,EAAI,SAAUtC,CAAG,EAC5C,OAEEuD,IAAcC,IAChBlB,EAAG,MAAQiB,GAETjB,EAAG,YAAcA,EAAG,WAAW,YAAciB,IAC/CjB,EAAG,WAAW,UAAYiB,EAE9B,CACF,CAWA,SAAShD,EAAkBkD,EAAYC,EAAa1D,EAAK,CAIvD,IAAI2D,EAAQ,CAAC,EAITC,EAAU,CAAC,EAIXC,EAAY,CAAC,EAIbC,EAAgB,CAAC,EAEjBC,EAAiB/D,EAAI,KAAK,MAG1BgE,EAAoB,IAAI,IAC5B,QAAWC,KAAgBR,EAAW,SACpCO,EAAkB,IAAIC,EAAa,UAAWA,CAAY,EAI5D,QAAWC,KAAkBR,EAAY,SAAU,CAEjD,IAAIS,EAAeH,EAAkB,IAAIE,EAAe,SAAS,EAC7DE,EAAepE,EAAI,KAAK,eAAekE,CAAc,EACrDG,EAAcrE,EAAI,KAAK,eAAekE,CAAc,EACpDC,GAAgBE,EACdD,EAEFR,EAAQ,KAAKM,CAAc,GAI3BF,EAAkB,OAAOE,EAAe,SAAS,EACjDL,EAAU,KAAKK,CAAc,GAG3BH,IAAmB,SAGjBK,IACFR,EAAQ,KAAKM,CAAc,EAC3BJ,EAAc,KAAKI,CAAc,GAI/BlE,EAAI,KAAK,aAAakE,CAAc,IAAM,IAC5CN,EAAQ,KAAKM,CAAc,CAInC,CAIAJ,EAAc,KAAK,GAAGE,EAAkB,OAAO,CAAC,EAChDM,EAAI,cAAeR,CAAa,EAEhC,IAAIxD,EAAW,CAAC,EAChB,QAAWiE,KAAWT,EAAe,CACnCQ,EAAI,WAAYC,CAAO,EAEvB,IAAIC,EACF,SAAS,YAAY,EAAE,yBAAyBD,EAAQ,SAAS,EAC9D,WAGL,GADAD,EAAIE,CAAM,EACNxE,EAAI,UAAU,gBAAgBwE,CAAM,IAAM,GAAO,CACnD,GACG,SAAUA,GAAUA,EAAO,MAC3B,QAASA,GAAUA,EAAO,IAC3B,CACsC,IAAIC,EACtCC,EAAU,IAAI,QAAQ,SAAUC,GAAU,CAC5CF,EAAUE,EACZ,CAAC,EACDH,EAAO,iBAAiB,OAAQ,UAAY,CAC1CC,EAAQ,CACV,CAAC,EACDnE,EAAS,KAAKoE,CAAO,CACvB,CACAhB,EAAY,YAAYc,CAAM,EAC9BxE,EAAI,UAAU,eAAewE,CAAM,EACnCb,EAAM,KAAKa,CAAM,CACnB,CACF,CAIA,QAAWI,KAAkBhB,EACvB5D,EAAI,UAAU,kBAAkB4E,CAAc,IAAM,KACtDlB,EAAY,YAAYkB,CAAc,EACtC5E,EAAI,UAAU,iBAAiB4E,CAAc,GAIjD,OAAA5E,EAAI,KAAK,iBAAiB0D,EAAa,CACrC,MAAOC,EACP,KAAME,EACN,QAASD,CACX,CAAC,EACMtD,CACT,CASA,SAASgE,KAAOO,EAAO,CAEvB,CAEA,SAAStF,GAAO,CAAC,CAQjB,SAASuF,GAAclF,EAAQ,CAI7B,IAAImF,EAAc,OAAO,OAAO,CAAC,EAAGzF,CAAQ,EAG5C,cAAO,OAAOyF,EAAanF,CAAM,EAGjCmF,EAAY,UAAY,OAAO,OAC7B,CAAC,EACDzF,EAAS,UACTM,EAAO,SACT,EAGAmF,EAAY,KAAO,OAAO,OAAO,CAAC,EAAGzF,EAAS,KAAMM,EAAO,IAAI,EAExDmF,CACT,CASA,SAAS9E,GAAmBP,EAASC,EAAYC,EAAQ,CACvD,IAAMoF,EAAeF,GAAclF,CAAM,EACzC,MAAO,CACL,OAAQF,EACR,WAAYC,EACZ,OAAQqF,EACR,WAAYA,EAAa,WACzB,aAAcA,EAAa,aAC3B,kBAAmBA,EAAa,kBAChC,MAAOC,GAAYvF,EAASC,CAAU,EACtC,QAAS,IAAI,IACb,cAAeqF,EAAa,QACxBE,GAAoBxF,EAASC,CAAU,EACvC,IAAI,IACR,OAAQqF,EAAa,QACjBG,GAAa,EACb,SAAS,cAAc,KAAK,EAChC,UAAWH,EAAa,UACxB,KAAMA,EAAa,IACrB,CACF,CAEA,SAASG,IAAe,CACtB,IAAMC,EAAS,SAAS,cAAc,KAAK,EAC3C,OAAAA,EAAO,OAAS,GAChB,SAAS,KAAK,sBAAsB,WAAYA,CAAM,EAC/CA,CACT,CAWA,SAASxD,EAAayD,EAAOC,EAAOtF,EAAK,CACvC,OAAIqF,GAAS,MAAQC,GAAS,KACrB,GAGPD,aAAiB,SACjBC,aAAiB,SACjBD,EAAM,UAAYC,EAAM,QAEpBD,EAAM,KAAO,IAAMA,EAAM,KAAOC,EAAM,GACjC,GAEAC,EAAuBvF,EAAKqF,EAAOC,CAAK,EAAI,EAGhD,EACT,CAQA,SAASlE,EAAY1B,EAAS6E,EAAS,CAMrC,OALI7E,GAAW,MAAQ6E,GAAW,MAMR7E,EAAS,IACTA,EAAS,KACP6E,EAAS,GAE5B,GAGP7E,EAAQ,WAAa6E,EAAQ,UACL7E,EAAS,UACP6E,EAAS,OAEvC,CASA,SAASxC,EAAmByD,EAAgBC,EAAczF,EAAK,CAClC,IAAI0F,EAASF,EACxC,KAAOE,IAAWD,GAAc,CAC9B,IAAIvD,EAAgCwD,EAGpCA,EAASxD,EAAS,YAClBC,EAAWD,EAAUlC,CAAG,CAC1B,CACA,OAAA2B,EAA2B3B,EAAKyF,CAAY,EACrCA,EAAa,WACtB,CAgBA,SAAS3D,GACPnC,EACA4B,EACAG,EACAD,EACAzB,EACA,CAEA,IAAI2F,EAA2BJ,EAC7BvF,EACA0B,EACAH,CACF,EAKIqE,EAAiB,KAGrB,GAAID,EAA2B,EAAG,CAGhCC,EAAiBnE,EAKjB,IAAIoE,EAAkB,EACtB,KAAOD,GAAkB,MAAM,CAE7B,GAAIhE,EAAaF,EAAUkE,EAAgB5F,CAAG,EAC5C,OAAO4F,EAST,GALAC,GAAmBN,EACjBvF,EACA4F,EACAjG,CACF,EACIkG,EAAkBF,EAGpB,OAAO,KAITC,EAAiBA,EAAe,WAClC,CACF,CACA,OAAOA,CACT,CAgBA,SAAS3D,GAActC,EAAY4B,EAAWG,EAAUD,EAAgBzB,EAAK,CAI3E,IAAI8F,EAAqBrE,EAIrBZ,EAAca,EAAS,YACvBqE,EAAwB,EAE5B,KAAOD,GAAsB,MAAM,CACjC,GAAIP,EAAuBvF,EAAK8F,EAAoBnG,CAAU,EAAI,EAGhE,OAAO,KAIT,GAAIyB,EAAY0E,EAAoBpE,CAAQ,EAC1C,OAAOoE,EAGT,GAAI1E,EAAY0E,EAAoBjF,CAAW,IAG7CkF,IAEAlF,EAAmCA,EAAa,YAI5CkF,GAAyB,GAC3B,OAAO,KAKXD,EAAqBA,EAAmB,WAC1C,CAEA,OAAOA,CACT,CAGA,IAAME,EAAuB,IAAI,QAOjC,SAASnG,GAAaF,EAAY,CAChC,IAAIsG,EAAS,IAAI,UAGbC,EAAyBvG,EAAW,QACtC,uCACA,EACF,EAGA,GACEuG,EAAuB,MAAM,UAAU,GACvCA,EAAuB,MAAM,UAAU,GACvCA,EAAuB,MAAM,UAAU,EACvC,CACA,IAAIC,EAAUF,EAAO,gBAAgBtG,EAAY,WAAW,EAE5D,GAAIuG,EAAuB,MAAM,UAAU,EACzC,OAAAF,EAAqB,IAAIG,CAAO,EACzBA,EACF,CAEL,IAAIC,EAAcD,EAAQ,WAC1B,OAAIC,GACFJ,EAAqB,IAAII,CAAW,EAC7BA,GAEA,IAEX,CACF,KAAO,CAOL,IAAID,EAJcF,EAAO,gBACvB,mBAAqBtG,EAAa,qBAClC,WACF,EAEc,KAAK,cAAc,UAAU,EACzC,QACF,OAAAqG,EAAqB,IAAIG,CAAO,EACzBA,CACT,CACF,CAOA,SAASpG,GAAiBJ,EAAY,CACpC,GAAIA,GAAc,KAGhB,OADoB,SAAS,cAAc,KAAK,EAE3C,GAAIqG,EAAqB,IAA4BrG,CAAW,EAErE,OAA+BA,EAC1B,GAAIA,aAAsB,KAAM,CAErC,IAAM0G,EAAc,SAAS,cAAc,KAAK,EAChD,OAAAA,EAAY,OAAO1G,CAAU,EACtB0G,CACT,KAAO,CAGL,IAAMA,EAAc,SAAS,cAAc,KAAK,EAChD,QAAW7G,IAAO,CAAC,GAAGG,CAAU,EAC9B0G,EAAY,OAAO7G,CAAG,EAExB,OAAO6G,CACT,CACF,CASA,SAASpF,GAAeL,EAAiBE,EAAaD,EAAa,CAIjE,IAAIyF,EAAQ,CAAC,EAIT3C,EAAQ,CAAC,EACb,KAAO/C,GAAmB,MACxB0F,EAAM,KAAK1F,CAAe,EAC1BA,EAAkBA,EAAgB,gBAIpC,IAAI2F,EAAOD,EAAM,IAAI,EACrB,KAAOC,IAAS,QACd5C,EAAM,KAAK4C,CAAI,EACfzF,EAAY,eAAe,aAAayF,EAAMzF,CAAW,EACzDyF,EAAOD,EAAM,IAAI,EAGnB,IADA3C,EAAM,KAAK7C,CAAW,EACfD,GAAe,MACpByF,EAAM,KAAKzF,CAAW,EACtB8C,EAAM,KAAK9C,CAAW,EACtBA,EAAcA,EAAY,YAE5B,KAAOyF,EAAM,OAAS,GAAG,CACvB,IAAMC,EAA4BD,EAAM,IAAI,EAC5CxF,EAAY,eAAe,aAAayF,EAAMzF,EAAY,WAAW,CACvE,CACA,OAAO6C,CACT,CASA,SAAShD,GAAkBhB,EAAYD,EAASM,EAAK,CAInD,IAAIwG,EACJA,EAAiB7G,EAAW,WAI5B,IAAI8G,EAAcD,EACdE,EAAQ,EACZ,KAAOF,GAAgB,CACrB,IAAIG,EAAWC,GAAaJ,EAAgB9G,EAASM,CAAG,EACpD2G,EAAWD,IACbD,EAAcD,EACdE,EAAQC,GAEVH,EAAiBA,EAAe,WAClC,CACA,OAAOC,CACT,CAWA,SAASG,GAAavB,EAAOC,EAAOtF,EAAK,CACvC,OAAIoB,EAAYkE,EAAOD,CAAK,EAGxB,GAAME,EAAuBvF,EAA0BqF,EAAQC,CAAK,EAGjE,CACT,CASA,SAASnD,EAAWD,EAAUlC,EAAK,CAGjC,GAFA2B,EAA2B3B,EAAKkC,CAAQ,EAGtClC,EAAI,OAAO,SACX6G,GAAqB7G,EAAKkC,CAAQ,GAClCA,aAAoB,QAEpB4E,EAAa5E,EAAUlC,CAAG,MACrB,CACL,GAAIA,EAAI,UAAU,kBAAkBkC,CAAQ,IAAM,GAAO,OACzDA,EAAS,YAAY,YAAYA,CAAQ,EACzClC,EAAI,UAAU,iBAAiBkC,CAAQ,CACzC,CACF,CAOA,SAAS4E,EAAaP,EAAMvG,EAAK,CAC/B,GAAIA,EAAI,UAAU,mBAAmBuG,CAAI,IAAM,GAO/C,GALA,MAAM,KAAKA,EAAK,UAAU,EAAE,QAASQ,GAAU,CAC7CD,EAAaC,EAAO/G,CAAG,CACzB,CAAC,EAGGA,EAAI,cAAc,IAA4BuG,EAAM,EAAE,EAEpDvG,EAAI,OAAO,WAEbA,EAAI,OAAO,WAAWuG,EAAM,IAAI,EAEhCvG,EAAI,OAAO,aAAauG,EAAM,IAAI,MAE/B,CACL,GAAIvG,EAAI,UAAU,kBAAkBuG,CAAI,IAAM,GAAO,OACrDA,EAAK,YAAY,YAAYA,CAAI,EACjCvG,EAAI,UAAU,iBAAiBuG,CAAI,CACrC,CACF,CAOA,SAAS9F,EAAkBuG,EAAMhH,EAAK,CAChCgH,aAAgB,UAClB,MAAM,KAAKhH,EAAI,OAAO,QAAQ,EAC3B,QAAQ,EACR,QAASiH,GAAY,CACpB,IAAMC,EAAeF,EAAK,cAAc,IAAIC,EAAQ,IAAI,EACxD,GAAIC,EAAc,CAEhB,GAAIA,EAAa,eAAe,WAG9B,IADAA,EAAa,cAAc,WAAWD,EAASC,CAAY,EACpDA,EAAa,cAAc,GAEhCD,EAAQ,WAAWC,EAAa,WAAY,IAAI,MAIlD,KADAA,EAAa,OAAOD,CAAO,EACpBC,EAAa,YAClBD,EAAQ,aAAaC,EAAa,WAAY,IAAI,EAIpDlH,EAAI,UAAU,kBAAkBiH,EAASC,CAAY,IAAM,KAE3D7F,EAAa6F,EAAcD,EAASjH,CAAG,EACvCA,EAAI,UAAU,iBAAiBiH,EAASC,CAAY,GAEtDA,EAAa,OAAO,CACtB,CACF,CAAC,EACHlH,EAAI,OAAO,OAAO,EAEtB,CAYA,SAASmH,GAAoBnH,EAAKoH,EAAI,CACpC,MAAO,CAACpH,EAAI,QAAQ,IAAIoH,CAAE,CAC5B,CASA,SAASC,GAAerH,EAAKoH,EAAIE,EAAY,CAE3C,OADYtH,EAAI,MAAM,IAAIsH,CAAU,GAAKjI,GAC5B,IAAI+H,CAAE,CACrB,CAQA,SAASzF,EAA2B3B,EAAKuG,EAAM,CAC7C,IAAIgB,EAAQvH,EAAI,MAAM,IAAIuG,CAAI,GAAKlH,EACnC,QAAW+H,KAAMG,EACfvH,EAAI,QAAQ,IAAIoH,CAAE,CAEtB,CAQA,SAASP,GAAqB7G,EAAKuG,EAAM,CACvC,QAAWa,KAAMpH,EAAI,MAAM,IAAIuG,CAAI,GAAKlH,EACtC,GAAIW,EAAI,cAAc,IAAIoH,CAAE,EAC1B,MAAO,GAGX,MAAO,EACT,CASA,SAAS7B,EAAuBvF,EAAKqF,EAAOC,EAAO,CACjD,IAAIkC,EAAYxH,EAAI,MAAM,IAAIqF,CAAK,GAAKhG,EACpCoI,EAAa,EACjB,QAAWL,KAAMI,EAGXL,GAAoBnH,EAAKoH,CAAE,GAAKC,GAAerH,EAAKoH,EAAI9B,CAAK,GAC/D,EAAEmC,EAGN,OAAOA,CACT,CAMA,SAASC,EAAavB,EAAS,CAC7B,IAAIwB,EAAQ,MAAM,KAAKxB,EAAQ,iBAAiB,MAAM,CAAC,EACvD,OAAIA,EAAQ,IACVwB,EAAM,KAAKxB,CAAO,EAEbwB,CACT,CAUA,SAASC,EAAqBrB,EAAMsB,EAAO,CACzC,IAAIC,EAAavB,EAAK,cACtB,QAAW/G,KAAOkI,EAAanB,CAAI,EAAG,CAIpC,IAAIwB,EAAUvI,EAGd,KAAOuI,IAAYD,GAAcC,GAAW,MAAM,CAChD,IAAIR,EAAQM,EAAM,IAAIE,CAAO,EAEzBR,GAAS,OACXA,EAAQ,IAAI,IACZM,EAAM,IAAIE,EAASR,CAAK,GAE1BA,EAAM,IAAI/H,EAAI,EAAE,EAChBuI,EAAUA,EAAQ,aACpB,CACF,CACF,CAYA,SAAS9C,GAAY+C,EAAYrI,EAAY,CAK3C,IAAIkI,EAAQ,IAAI,IAChB,OAAAD,EAAqBI,EAAYH,CAAK,EACtCD,EAAqBjI,EAAYkI,CAAK,EAC/BA,CACT,CAOA,SAAS3C,GAAoB8C,EAAYrI,EAAY,CACnD,IAAMsI,EAAe1B,GAASA,EAAK,QAAU,IAAMA,EAAK,GAClD2B,EAAW,IAAI,IAAIR,EAAaM,CAAU,EAAE,IAAIC,CAAW,CAAC,EAE9DE,EAAa,IAAI,IACrB,QAAW5D,KAAWmD,EAAa/H,CAAU,EACvCuI,EAAS,IAAID,EAAY1D,CAAO,CAAC,GACnC4D,EAAW,IAAI5D,EAAQ,EAAE,EAG7B,OAAO4D,CACT,CAKA,MAAO,CACL,MAAA1I,EACA,SAAAH,CACF,CACF,EAAG,ECz5CI,IAAM8I,EAAN,KAAuB,CAC5B,aAAa,OAAOC,EAAiB,CACnC,IAAMC,EAAW,MAAMC,EAAmB,EAC1C,OAAO,IAAIH,EAAiBE,EAAUD,CAAe,EAAE,OAAO,CAChE,CAEA,aAAa,WAAY,CACvB,gBAAS,YAAY,QAASG,GAAe,CAC3C,SAAS,OAAOA,EAAW,UAAU,EACrC,SAAS,SAASA,EAAW,WAAYA,EAAW,WAAW,CACjE,CAAC,EAEM,QAAQ,QAAQ,CACzB,CAEA,YAAYF,EAAUD,EAAiB,CACrC,KAAK,SAAWC,EAChB,KAAK,gBAAkBD,EACvB,KAAK,YAAc,OAAO,QAC5B,CAEA,MAAM,QAAS,CACbI,EAAI,gCAAgC,EAEpC,KAAK,YAAY,KAAK,EAEtB,MAAM,KAAKC,GAAkC,EAC7C,KAAKC,GAAkC,EAEvC,KAAK,YAAY,MAAM,CACzB,CAEA,KAAMD,IAAoC,CACxC,MAAM,QAAQ,IACZ,KAAKE,GAAiC,IAAI,MAAOC,GAC/C,KAAKC,GAA0BD,CAAU,CAC3C,CACF,CACF,CAEA,GAAID,IAAmC,CACrC,YAAK,wBACH,KAAK,yBACL,KAAKG,GAAyB,OAAQC,GACpC,KAAKC,GAAwBD,CAAI,CACnC,EACK,KAAK,uBACd,CAEA,GAAID,IAA2B,CAC7B,OAAO,OAAO,KAAK,KAAKG,EAAsB,EAAE,OAAQF,GACtDA,EAAK,SAAS,aAAa,CAC7B,CACF,CAEAC,GAAwBD,EAAM,CAC5B,OACE,KAAKG,GAAuBH,CAAI,IAAM,KAAKI,EAE/C,CAEA,GAAIA,IAA+B,CACjC,YAAK,4BACH,KAAK,6BACL,KAAKD,GAAuB,KAAK,eAAe,EAC3C,KAAK,2BACd,CAEA,GAAID,IAAyB,CAC3B,YAAK,cAAgB,KAAK,eAAiB,KAAKG,GAAoB,EAC7D,KAAK,aACd,CAEAA,IAAsB,CACpB,IAAMC,EAAkB,KAAK,SAAS,cACpC,wBACF,EACA,OAAO,KAAK,MAAMA,EAAgB,IAAI,EAAE,OAC1C,CAEA,KAAMR,GAA0BD,EAAY,CAC1CJ,EAAI,IAAKI,GAAY,EAErB,IAAMU,EAAiB,KAAKJ,GAAuBN,CAAU,EAGvDW,EAAS,MAAM,OAFRC,EAAe,KAAKC,GAAmBb,CAAU,CAAC,GAI/D,KAAKc,GAAoBJ,EAAgBC,CAAM,CACjD,CAEAb,IAAoC,CAClC,KAAKiB,GAAqB,QAASpB,GACjC,KAAKqB,GAAsBrB,EAAW,UAAU,CAClD,CACF,CAEA,GAAIoB,IAAuB,CACzB,OAAI,KAAKE,GACA,CAAC,EAED,KAAK,YAAY,YAAY,OACjCtB,GACC,KAAKY,KAAiCZ,EAAW,UACrD,CAEJ,CAEA,GAAIsB,IAA2B,CAC7B,OAAO,KAAKlB,GAAiC,OAAS,CACxD,CAEAc,GAAmBb,EAAY,CAC7B,OAAO,KAAKK,GAAuBL,EACrC,CAEAM,GAAuBH,EAAM,CAC3B,OAAOA,EACJ,QAAQ,OAAQ,EAAE,EAClB,QAAQ,iBAAkB,EAAE,EAC5B,QAAQ,cAAe,EAAE,EACzB,QAAQ,MAAO,IAAI,EACnB,QAAQ,KAAM,GAAG,EACjB,QAAQ,QAAS,EAAE,CACxB,CAEAW,GAAoBI,EAAMP,EAAQ,CAChC,KAAK,YAAY,OAAOO,CAAI,EAC5B,KAAK,YAAY,SAASA,EAAMP,EAAO,OAAO,CAChD,CAEAK,GAAsBE,EAAM,CAC1BtB,EAAI,wBAAyBsB,GAAM,EACnC,KAAK,YAAY,OAAOA,CAAI,CAC9B,CACF,ECrIO,IAAMC,EAAN,KAAwB,CAC7B,aAAa,QAAS,CACpB,OAAO,IAAIA,EAAkB,EAAE,OAAO,CACxC,CAEA,MAAM,QAAS,CACb,MAAM,KAAKC,GAAY,EACvB,MAAM,KAAKC,GAAgB,CAC7B,CAEA,KAAMD,IAAc,CAClBE,EAAI,gBAAgB,EAEpB,IAAMC,EAAmB,MAAMC,EAAmB,EAClD,YAAKC,GAAYF,EAAiB,IAAI,EAC/BA,CACT,CAEAE,GAAYC,EAAS,CACnBC,EAAU,MAAM,SAAS,KAAMD,CAAO,CACxC,CAEA,KAAML,IAAkB,CACtB,MAAMO,EAAiB,UAAU,CACnC,CACF,ECvBO,IAAMC,EAAN,KAAkB,CACvB,aAAa,UAAUC,EAAQ,CAC7B,OAAO,IAAID,EAAY,GAAGC,CAAM,EAAE,OAAO,CAC3C,CAEA,YAAYC,EAAc,IAAK,CAC7B,KAAK,YAAcA,CACrB,CAEA,MAAM,QAAS,CACbC,EAAI,eAAe,EACnB,MAAM,QAAQ,IAAI,MAAM,KAAKC,GAAgB,CAAC,CAChD,CAEA,KAAMA,IAAkB,CAEtB,OADiB,MAAM,KAAKC,GAAiB,GAC7B,IAAKC,GAAS,KAAKC,GAAoBD,CAAI,CAAC,CAC9D,CAEA,KAAMD,IAAmB,CACvB,IAAMG,EAAmB,MAAMC,EAAmB,EAClD,OAAO,MAAM,KACXD,EAAiB,KAAK,iBAAiB,wBAAwB,CACjE,CACF,CAEAD,GAAoBD,EAAM,CACxB,OAAI,KAAKI,GAAkBJ,CAAI,EACtB,KAAKK,GAAYL,CAAI,EAErB,QAAQ,QAAQ,CAE3B,CAEAI,GAAkBJ,EAAM,CACtB,OAAO,KAAK,YAAY,KAAKA,EAAK,aAAa,MAAM,CAAC,CACxD,CAEA,KAAMK,GAAYL,EAAM,CACtB,OAAO,IAAI,QAASM,GAAY,CAC9B,IAAMC,EAAOP,EAAK,aAAa,MAAM,EAC/BQ,EACJ,KAAKC,GAAqBT,CAAI,GAAK,KAAKU,GAAeV,CAAI,EAE7DQ,EAAQ,aAAa,OAAQG,EAAeX,EAAK,aAAa,MAAM,CAAC,CAAC,EACtEQ,EAAQ,OAAS,IAAM,CACrBX,EAAI,IAAKU,GAAM,EACfD,EAAQ,CACV,CACF,CAAC,CACH,CAEAG,GAAqBT,EAAM,CACzB,OAAO,KAAKY,GAAU,KACnBJ,GACCK,EAAuBb,EAAK,IAAI,IAChCa,EAAuBL,EAAQ,IAAI,CACvC,CACF,CAEA,GAAII,IAAY,CACd,OAAO,MAAM,KAAK,SAAS,iBAAiB,wBAAwB,CAAC,CACvE,CAEAF,GAAeV,EAAM,CACnB,gBAAS,KAAK,OAAOA,CAAI,EAClBA,CACT,CACF,ECtEO,IAAMc,EAAN,KAA8B,CACnC,aAAa,OAAQ,CACnB,IAAMC,EAAM,IAAI,YAAY,iCAAiC,EAE7DA,EAAI,iBAAiB,cAAgBC,IAEjC,iBAAiB,OAAO,mBAAqB,QACzCC,EACAC,GAEU,OAAO,CACxB,EAEDH,EAAI,iBAAiB,kBAAoBC,GAAU,CACjD,IAAMG,EAAO,KAAK,MAAMH,EAAM,IAAI,EAClC,OAAOI,EAAiB,OAAOD,EAAK,IAAI,CAC1C,CAAC,EAEDJ,EAAI,iBAAiB,aAAeC,GAAU,CAC5C,IAAMG,EAAO,KAAK,MAAMH,EAAM,IAAI,EAClC,OAAOK,EAAY,OAAOF,EAAK,IAAI,CACrC,CAAC,CACH,CACF,ECzBA,IAAMG,EAAiC,CACrC,eAAgB,GAChB,iBAAkB,OACpB,EAEMC,EAAmB,CACvB,OAAQ,CAAE,GAAGD,CAA+B,CAC9C,EAEA,OAAO,iBAAmBC,EAE1B,IAAMC,GAAmB,CACvB,eAAgB,UAChB,iBAAkB,oBACpB,EAEMC,EAAc,SAAY,CAC9B,OAAO,QAAQD,EAAgB,EAAE,QAAQ,CAAC,CAACE,EAAKC,CAAQ,IAAM,CAC5DJ,EAAiB,OAAOG,GACtBE,EAAyBD,CAAQ,GAAKL,EAA+BI,EACzE,CAAC,CACH,EAEA,SAAS,iBAAiB,mBAAoB,SAAY,CACxD,MAAMD,EAAY,EAElB,MAAMI,EAAwB,MAAM,CACtC,CAAC,EAED,SAAS,iBAAiB,aAAc,SAAY,CAClD,MAAMJ,EAAY,CACpB,CAAC,EAED,IAAOK,EAAQP",
  "names": ["log", "messages", "js_default", "ReplaceHtmlReloader", "#reloadHtml", "log", "#keepScrollPosition", "#visitCurrentPage", "resolve", "pathWithoutAssetDigest", "path", "urlWithParams", "urlString", "params", "url", "key", "value", "cacheBustedUrl", "reloadHtmlDocument", "currentUrl", "response", "fetchedHTML", "getConfigurationProperty", "name", "Idiomorph", "EMPTY_SET", "defaults", "noOp", "elt", "morph", "oldNode", "newContent", "config", "parseContent", "normalizedContent", "normalizeContent", "ctx", "createMorphContext", "morphNormalizedContent", "normalizedNewContent", "oldHead", "newHead", "promises", "handleHeadElement", "morphChildren", "restoreFromPantry", "bestMatch", "findBestNodeMatch", "previousSibling", "nextSibling", "morphedNode", "morphOldNodeTo", "elements", "insertSiblings", "ignoreValueOfActiveElement", "possibleActiveElement", "isSoftMatch", "syncNodeFrom", "newParent", "oldParent", "nextNewChild", "insertionPoint", "newChild", "removeIdsFromConsideration", "isIdSetMatch", "idSetMatch", "findIdSetMatch", "removeNodesBetween", "softMatch", "findSoftMatch", "tempNode", "removeNode", "ignoreAttribute", "attr", "to", "updateType", "from", "type", "fromEl", "toEl", "fromAttributes", "toAttributes", "fromAttribute", "i", "toAttribute", "syncInputValue", "syncBooleanAttribute", "attributeName", "fromLiveValue", "toLiveValue", "ignoreUpdate", "fromValue", "toValue", "newHeadTag", "currentHead", "added", "removed", "preserved", "nodesToAppend", "headMergeStyle", "srcToNewHeadNodes", "newHeadChild", "currentHeadElt", "inNewContent", "isReAppended", "isPreserved", "log", "newNode", "newElt", "resolve", "promise", "_resolve", "removedElement", "_args", "mergeDefaults", "finalConfig", "mergedConfig", "createIdMap", "createPersistentIds", "createPantry", "pantry", "node1", "node2", "getIdIntersectionCount", "startInclusive", "endExclusive", "cursor", "newChildPotentialIdCount", "potentialMatch", "otherMatchCount", "potentialSoftMatch", "siblingSoftMatchCount", "generatedByIdiomorph", "parser", "contentWithSvgsRemoved", "content", "htmlElement", "dummyParent", "stack", "node", "currentElement", "bestElement", "score", "newScore", "scoreElement", "hasPersistentIdNodes", "moveToPantry", "child", "root", "element", "matchElement", "isIdInConsideration", "id", "idIsWithinNode", "targetNode", "idSet", "sourceSet", "matchCount", "nodesWithIds", "nodes", "populateIdMapForNode", "idMap", "nodeParent", "current", "oldContent", "toIdTagName", "oldIdSet", "matchIdSet", "StimulusReloader", "changedFilePath", "document", "reloadHtmlDocument", "controller", "log", "#reloadChangedStimulusControllers", "#unloadDeletedStimulusControllers", "#stimulusControllerPathsToReload", "moduleName", "#reloadStimulusController", "#stimulusControllerPaths", "path", "#shouldReloadController", "#stimulusPathsByModule", "#extractControllerName", "#changedControllerIdentifier", "#parseImportmapJson", "importmapScript", "controllerName", "module", "cacheBustedUrl", "#pathForModuleName", "#registerController", "#controllersToUnload", "#deregisterController", "#didChangeTriggerAReload", "name", "MorphHtmlReloader", "#reloadHtml", "#reloadStimulus", "log", "reloadedDocument", "reloadHtmlDocument", "#updateBody", "newBody", "Idiomorph", "StimulusReloader", "CssReloader", "params", "filePattern", "log", "#reloadAllLinks", "#loadNewCssLinks", "link", "#reloadLinkIfNeeded", "reloadedDocument", "reloadHtmlDocument", "#shouldReloadLink", "#reloadLink", "resolve", "href", "newLink", "#findExistingLinkFor", "#appendNewLink", "cacheBustedUrl", "#cssLinks", "pathWithoutAssetDigest", "ServerSentEventsChannel", "sse", "event", "MorphHtmlReloader", "ReplaceHtmlReloader", "data", "StimulusReloader", "CssReloader", "HotwireHotreloadDefaultConfigs", "HotwireHotreload", "configProperties", "syncConfigs", "key", "property", "getConfigurationProperty", "ServerSentEventsChannel", "js_default"]
}
